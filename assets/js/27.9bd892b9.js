(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{610:function(t,v,_){"use strict";_.r(v);var e=_(5),a=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"行内元素设置padding、margin有什么效果"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#行内元素设置padding、margin有什么效果"}},[t._v("#")]),t._v(" 行内元素设置padding、margin有什么效果？")]),t._v(" "),_("p",[t._v("左右边距有效果，但上下边距无效，虽然在显示效果上是增加了但并不会挤走其他的元素，盒子实际上并没有被撑开。 要特别注意img是一个特例，它虽然是行内元素，但也是置换元素、行内块元素，所以它的性质不同于行内元素。对于img设置padding和margin都是有效的。")]),t._v(" "),_("blockquote",[_("p",[t._v("HTML中的img、input、textarea、select、object都是置换元素。 这些元素往往没有实际的内容，即是一个空元素。")])]),t._v(" "),_("h2",{attrs:{id:"css元素分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css元素分类"}},[t._v("#")]),t._v(" CSS元素分类")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("常用的块状元素（block元素）")]),t._v(" "),_("p",[t._v("总是独占一行，元素占据的高度，顶底左右边距可以人为设置；其宽度缺省为所在容器的100%，可人为设置；")]),t._v(" "),_("p",[_("code",[t._v("<div>、<p>、<h1>...<h6>、<ol>、<ul>、<dl>、<table>、<address>、<blockquote> 、<form>")])])]),t._v(" "),_("li",[_("p",[t._v("常用的内联元素(inline元素)")]),t._v(" "),_("p",[t._v("元素的高度，行高，顶底边距由元素所包含的图片或文字所决定，不可改变；其宽度为内容文字或图片的宽度所决定，而其左右边距可人为设置。 行内元素的padding、margin水平方向有效，竖直方向无效")]),t._v(" "),_("p",[_("code",[t._v("<a>、<span>、<br>、<i>、<em>、<strong>、<label>、<q>、<var>、<cite>、<code>")])])]),t._v(" "),_("li",[_("p",[t._v("常用的内联块状元素（inline-block）")]),t._v(" "),_("p",[_("code",[t._v("<img>、<input>")])])])]),t._v(" "),_("h2",{attrs:{id:"行内块元素之间出现间隙的原因以及如何解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#行内块元素之间出现间隙的原因以及如何解决"}},[t._v("#")]),t._v(" 行内块元素之间出现间隙的原因以及如何解决？")]),t._v(" "),_("p",[t._v("原因：内元素之间产生空隙的，是由于换行符、tab（制表符）、空格等字符引起;")]),t._v(" "),_("p",[t._v("解决方案：")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("暴力删除行内元素之间的换行符、tab（制表符）、空格等字符")])]),t._v(" "),_("li",[_("p",[t._v("利用HTML注释")])]),t._v(" "),_("li",[_("p",[t._v("指定margin属性为负数 ，但必须根据具体情况去计算，有时还不对，应该尽量避免这样做。")])]),t._v(" "),_("li",[_("p",[t._v("设置"),_("code",[t._v("font-size：0")]),t._v("，消除换行符、tab（制表符）、空格等字符 。但 IE6，IE7浏览器当设置font-size：0时，换行符、tab（制表符）、空格始终存在1px的空隙 ； 最新版本的Safari浏览器，Chrome浏览器不支持字体大小为0")])]),t._v(" "),_("li",[_("p",[t._v("设置浮动"),_("code",[t._v("float: left;")])])]),t._v(" "),_("li",[_("p",[t._v("正常解决方案为：")])])]),t._v(" "),_("div",{staticClass:"language-css extra-class"},[_("pre",{pre:!0,attrs:{class:"language-css"}},[_("code",[t._v(" "),_("span",{pre:!0,attrs:{class:"token selector"}},[t._v("html")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n　　-webkit-text-size-adjust"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("none"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 使用webkit的私有属性，让字体大小不受设备终端的调整，可定义字体大小小于12px */")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".span-wrap")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-size")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("0"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 所有浏览器 */")]),t._v("\n    *"),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("word-spacing")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("-1px"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 使用word-spacing 修复 IE6、7 中始终存在的 1px 空隙，减少单词间的空白（即字间隔） */")]),t._v("\n "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n "),_("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".span-wrap span")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-size")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 12px"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("letter-spacing")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" normal"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 设置字母、字间距为0 */")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("word-spacing")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" normal"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 设置单词、字段间距为0 */")]),t._v("\n "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),_("h2",{attrs:{id:"html-解决空格显示问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#html-解决空格显示问题"}},[t._v("#")]),t._v(" html 解决空格显示问题")]),t._v(" "),_("p",[t._v("在html中手动输入多个空格或者是回车，在页面解析的时候都被解析成一个空白显示")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("使用转义字符，如 等，代替手动输入的空格，")])]),t._v(" "),_("li",[_("p",[t._v("使用全角空格，全角空格被解析为汉字处理，")])]),t._v(" "),_("li",[_("p",[t._v("控制css：将包裹文字的标签的样式增加设置：white-space:pre，浏览器会保留文本中的空格和换行")])]),t._v(" "),_("li",[_("p",[t._v("使用pre标签包裹文字")])])]),t._v(" "),_("h2",{attrs:{id:"transform动画和直接使用-keyframes-设置left属性-去改变位置哪个性能更好-为什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#transform动画和直接使用-keyframes-设置left属性-去改变位置哪个性能更好-为什么"}},[t._v("#")]),t._v(" transform动画和直接使用@keyframes 设置left属性 去改变位置哪个性能更好，为什么？")]),t._v(" "),_("p",[_("code",[t._v("transform: translateX()")]),t._v(" 比 left 更流畅 。")]),t._v(" "),_("p",[t._v("​\tCSS transform属性并不会触发当前元素或附近元素的relayout。浏览器将当前元素视为一个整体，它会缩放、旋转、移动这一整个元素。GPU自动绘制同一张位图到不同的位置、旋转角度和缩放比例。")]),t._v(" "),_("p",[t._v("​\t而 top和left的改变会触发浏览器的 reflow和 repaint 。然后整个动画过程都在不断触发浏览器的重新渲染，这个过程是很影响性能的。")]),t._v(" "),_("h2",{attrs:{id:"position的定位原点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#position的定位原点"}},[t._v("#")]),t._v(" position的定位原点？")]),t._v(" "),_("ol",[_("li",[_("p",[_("strong",[t._v("absolute")]),_("br"),t._v("\n生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的\n一级position设置为absolute或者relative的父元素的padding box的左上角为原点的。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("fixed（老IE不支持）")]),_("br"),t._v("\n生成绝对定位的元素，相对于浏览器窗口进行定位。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("relative")]),_("br"),t._v("\n生成相对定位的元素，相对于其元素本身所在正常位置进行定位。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("static")]),_("br"),t._v("\n默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("inherit")]),_("br"),t._v("\n规定从父元素继承position属性的值。")])])]),t._v(" "),_("h2",{attrs:{id:"标准盒模型与怪异盒模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标准盒模型与怪异盒模型"}},[t._v("#")]),t._v(" 标准盒模型与怪异盒模型")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("标准盒模型又称W3C标准盒模型，其中标准盒模型的 width 等于 content 的宽度，标准盒模型的 height 等于 content 的高度。\n"),_("code",[t._v("标准盒大小计算公式：width(content) + padding + border + margin")])])]),t._v(" "),_("li",[_("p",[t._v("怪异盒模型又称IE盒子模型，其中怪异盒子模型的 width 等于 content + padding + border 的宽度，怪异盒子模型的 height 等于 content + padding + border 的高度。")])]),t._v(" "),_("li",[_("p",[t._v("在 css3 中添加了对盒模型设置的属性 box-sizing，可以根据需要自由调整。"),_("code",[t._v("浏览器支持：IE8+")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[t._v("属性值")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("描述")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("content-box")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("默认值，盒子宽度高度等于content（标准盒模型）。")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("border-box")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("盒子宽度高度等于content + padding + border（怪异盒模型）。")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("padding-box")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("盒子宽度高度等于content + padding。")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("inherit")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("从父元素中继承 box-sizing 属性的值。")])])])])])]),t._v(" "),_("h2",{attrs:{id:"行内元素与块级元素有哪些区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#行内元素与块级元素有哪些区别"}},[t._v("#")]),t._v(" 行内元素与块级元素有哪些区别")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("块级元素 display: block / table")]),t._v(" "),_("p",[t._v("特点：独占一行，不管内容的长度")]),t._v(" "),_("p",[t._v("div h1(hx) p ul li table form")])]),t._v(" "),_("li",[_("p",[t._v("内联元素 display: inline / inline-block")]),t._v(" "),_("p",[t._v("特点： 不会独占一行，会紧跟着排列，直到没有足够的空间")]),t._v(" "),_("p",[t._v("span strong label a img input select textarea iframe")])])]),t._v(" "),_("h2",{attrs:{id:"margin合并"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#margin合并"}},[t._v("#")]),t._v(" margin合并")]),t._v(" "),_("p",[_("strong",[t._v("定义")])]),t._v(" "),_("p",[t._v("块级元素的上外边距或下外边距有时（直接接触/相邻时）会合并为一个外边距，这种合并行为叫做margin合并。**注意浮动元素或者有绝对定位的元素不会发生margin合并的行为。 **")]),t._v(" "),_("p",[t._v("只有"),_("strong",[t._v("普通文档流中")]),t._v("块级元素（block）的"),_("strong",[t._v("垂直外边距")]),t._v("才会发生外边距合并。行内框，浮动框或绝对定位之间的外边距不会合并。")]),t._v(" "),_("p",[_("strong",[t._v("合并原则")])]),t._v(" "),_("p",[t._v("正正取最大，负负取最负，正负就相加")]),t._v(" "),_("p",[_("strong",[t._v("分类")])]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("相邻元素之间margin合并")])])]),t._v(" "),_("p",[t._v("相邻元素之间的margin合并规则很简单，按照上述的合并原则进行计算得到一个外边距即可。")]),t._v(" "),_("p",[t._v("解决方法：用padding代替margin")]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("p",[_("strong",[t._v("父元素和第一个/最后一个子元素之间margin合并")])]),t._v(" "),_("p",[t._v("以父元素和第一个子元素为例。当第一个子元素设置margin-top时会‘溢出’到父元素上，如果父元素也存在margin-top属性，则按照合并规则进行计算。")])])]),t._v(" "),_("p",[t._v("解决方法：")]),t._v(" "),_("ol",[_("li",[t._v("父元素加border")]),t._v(" "),_("li",[t._v("父元素添加padding来代替子元素的margin")]),t._v(" "),_("li",[t._v("父元素加height、min-height、max-height(适用于最后一个子元素的margin合并)")]),t._v(" "),_("li",[t._v("把父元素设置为BFC（例如添加绝对定位，设置overflow）")])]),t._v(" "),_("h2",{attrs:{id:"margin-负值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#margin-负值"}},[t._v("#")]),t._v(" margin 负值")]),t._v(" "),_("p",[t._v("margin- top 负值  元素向上拖拽")]),t._v(" "),_("p",[t._v("margin- left 负值  元素向左拖拽")]),t._v(" "),_("p",[t._v("margin- bottom 负值  元素本身不变，下方元素上移")]),t._v(" "),_("p",[t._v("margin- right 负值  元素本身不变，右侧元素左移")]),t._v(" "),_("h2",{attrs:{id:"bfc-块级格式化上下文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bfc-块级格式化上下文"}},[t._v("#")]),t._v(" BFC 块级格式化上下文")]),t._v(" "),_("p",[t._v("形成独立的渲染区域")]),t._v(" "),_("p",[t._v("内部元素的渲染不会影响到外界")]),t._v(" "),_("p",[t._v("形成 BFC 常见的条件")]),t._v(" "),_("ul",[_("li",[t._v("根元素或包含根元素的元素")]),t._v(" "),_("li",[t._v("浮动元素：  float不是none")]),t._v(" "),_("li",[t._v("绝对定位元素： position是absolute 或 fixed")]),t._v(" "),_("li",[t._v("块级元素： overflow 不是 visible")]),t._v(" "),_("li",[t._v("flex 元素")]),t._v(" "),_("li",[t._v("inline-block 元素")])]),t._v(" "),_("p",[t._v("应用场景:"),_("br"),t._v("\n清除浮动 等"),_("br"),t._v(" "),_("strong",[t._v("回答:")]),_("br"),t._v("\nBFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也\n不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。")]),t._v(" "),_("p",[t._v("一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些\n属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。")]),t._v(" "),_("h2",{attrs:{id:"ifc-是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ifc-是什么"}},[t._v("#")]),t._v(" IFC 是什么？")]),t._v(" "),_("p",[t._v("IFC指的是行级格式化上下文，它有这样的一些布局规则：")]),t._v(" "),_("p",[t._v("（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。"),_("br"),t._v("\n（2）当一行不够的时候会自动切换到下一行。"),_("br"),t._v("\n（3）行级上下文的高度由内部最高的内联盒子的高度决定。")]),t._v(" "),_("h2",{attrs:{id:"css经典布局之-圣杯布局与双飞翼布局"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css经典布局之-圣杯布局与双飞翼布局"}},[t._v("#")]),t._v(" CSS经典布局之：圣杯布局与双飞翼布局")]),t._v(" "),_("p",[t._v("圣杯布局和双飞翼布局达到的效果基本相同，都是侧边两栏宽度固定，中间栏宽度自适应。 主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样，圣杯布局是在父元素上设置了padding-left和padding-right，在给左右两边的内容设置position为relative，通过左移和右移来使得左右两边的内容得以很好的展现，而双飞翼则是在center这个div中再加了一个div来放置内容，在给这个新的div设置margin-left和margin-right 。")]),t._v(" "),_("h3",{attrs:{id:"圣杯布局"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#圣杯布局"}},[t._v("#")]),t._v(" 圣杯布局")]),t._v(" "),_("p",[_("strong",[t._v("布局要求：")])]),t._v(" "),_("ul",[_("li",[t._v("header和footer各自占领屏幕所有宽度，高度固定。")]),t._v(" "),_("li",[t._v("中间的container是一个三栏布局。")]),t._v(" "),_("li",[t._v("三栏布局两侧宽度固定不变，中间部分自动填充整个区域。")]),t._v(" "),_("li",[t._v("中间部分的高度是三栏中最高的区域的高度。")])]),t._v(" "),_("p",[_("strong",[t._v("实现：")])]),t._v(" "),_("p",[_("strong",[t._v("【1】浮动")])]),t._v(" "),_("ul",[_("li",[t._v("先定义好header和footer的样式，使之横向撑满。")]),t._v(" "),_("li",[t._v("在container中的三列设为浮动和相对定位(后面会用到)，center要放在最前面，footer清除浮动。")]),t._v(" "),_("li",[t._v("三列的左右两列分别定宽200px和150px，中间部分center设置100%撑满")]),t._v(" "),_("li",[t._v("这样因为浮动的关系，center会占据整个container，左右两块区域被挤下去了")]),t._v(" "),_("li",[t._v("接下来设置left的 margin-left: -100%;，让left回到上一行最左侧")]),t._v(" "),_("li",[t._v("但这会把center给遮住了，所以这时给外层的container设置 padding-left: 200px;padding-right: 150px;，给left和right空出位置")]),t._v(" "),_("li",[t._v("这时left并没有在最左侧，因为之前已经设置过相对定位，所以通过 left: -200px; 把left拉回最左侧")]),t._v(" "),_("li",[t._v("同样的，对于right区域，设置 margin-left: -150px; 把right拉回第一行")]),t._v(" "),_("li",[t._v("这时右侧空出了150px的空间，所以最后设置 right: -150px;把right区域拉到最右侧就行了。")])]),t._v(" "),_("p",[_("strong",[t._v("【2】flex弹性盒子")])]),t._v(" "),_("ul",[_("li",[t._v("header和footer设置样式，横向撑满。")]),t._v(" "),_("li",[t._v("container中的left、center、right依次排布即可")]),t._v(" "),_("li",[t._v("给container设置弹性布局 "),_("code",[t._v("display: flex;")])]),t._v(" "),_("li",[t._v("left和right区域定宽，center设置 "),_("code",[t._v("flex: 1;")]),t._v(" 即可")])]),t._v(" "),_("p",[_("strong",[t._v("【3】grid布局")])]),t._v(" "),_("ul",[_("li",[t._v("给body元素添加display: grid;属性变成一个grid(网格)")]),t._v(" "),_("li",[t._v("给header元素设置grid-row: 1; 和 grid-column: 1/5; 意思是占据第一行网格的从第一条列网格线开始到第五条列网格线结束")]),t._v(" "),_("li",[t._v("给footer元素设置grid-row: 1; 和 grid-column: 1/5; 意思是占据第三行网格的从第一条列网格线开始到第五条列网格线结束")]),t._v(" "),_("li",[t._v("给left元素设置grid-row: 2; 和 grid-column: 1/2; 意思是占据第二行网格的从第一条列网格线开始到第二条列网格线结束")]),t._v(" "),_("li",[t._v("给center元素设置grid-row: 2; 和 grid-column: 2/4; 意思是占据第二行网格的从第二条列网格线开始到第四条列网格线结束")]),t._v(" "),_("li",[t._v("给right元素设置grid-row: 2; 和 grid-column: 4/5; 意思是占据第二行网格的从第四条列网格线开始到第五条列网格线结束")])]),t._v(" "),_("h3",{attrs:{id:"双飞翼布局"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双飞翼布局"}},[t._v("#")]),t._v(" 双飞翼布局")]),t._v(" "),_("p",[_("strong",[t._v("布局要求：")])]),t._v(" "),_("ul",[_("li",[t._v("header和footer各自占领屏幕所有宽度，高度固定。")]),t._v(" "),_("li",[t._v("中间的container是一个三栏布局。")]),t._v(" "),_("li",[t._v("三栏布局两侧宽度固定不变，中间部分自动填充整个区域。")]),t._v(" "),_("li",[t._v("中间部分的高度是三栏中最高的区域的高度。")])]),t._v(" "),_("p",[_("strong",[t._v("实现：")])]),t._v(" "),_("ul",[_("li",[t._v("left、center、right三种都设置左浮动")]),t._v(" "),_("li",[t._v("设置center宽度为100%")]),t._v(" "),_("li",[t._v("设置负边距，left设置负边距为100%，right设置负边距为自身宽度")]),t._v(" "),_("li",[t._v("设置content的margin值为左右两个侧栏留出空间，margin值大小为left和right宽度")])]),t._v(" "),_("h2",{attrs:{id:"line-height继承的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#line-height继承的问题"}},[t._v("#")]),t._v(" line-height继承的问题")]),t._v(" "),_("h3",{attrs:{id:"当前元素本身设置了line-height值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#当前元素本身设置了line-height值"}},[t._v("#")]),t._v(" 当前元素本身设置了line-height值：")]),t._v(" "),_("ul",[_("li",[t._v("设置的值为固定值，如：22px，1em等，则line-height为设置的值；")]),t._v(" "),_("li",[t._v("设置的值为百分比，如：120%，则line-height为120% * 当前元素的font-size；")]),t._v(" "),_("li",[t._v("设置的值为缩放因子，如：1.4，则line-height为1.4 * 当前元素的font-size；")])]),t._v(" "),_("h3",{attrs:{id:"当前元素本身未设置line-height值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#当前元素本身未设置line-height值"}},[t._v("#")]),t._v(" 当前元素本身未设置line-height值：")]),t._v(" "),_("ul",[_("li",[t._v("距离当前最近的祖先元素P设置了line-height为固定值，如22px，则当前元素E的line-height值为22px；")]),t._v(" "),_("li",[t._v("距离当前最近的祖先元素P设置了line-height为百分比，如120%，则当前元素E的line-height值为120% * 祖先元素P的font-size；")]),t._v(" "),_("li",[t._v("距离当前最近的祖先元素P设置了line-height为缩放因子，如1.4，则当前元素E的line-height值为1.4 * 当前元素E的font-size;")])]),t._v(" "),_("h2",{attrs:{id:"css中的长度单位"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css中的长度单位"}},[t._v("#")]),t._v(" CSS中的长度单位")]),t._v(" "),_("h3",{attrs:{id:"绝对长度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#绝对长度"}},[t._v("#")]),t._v(" 绝对长度")]),t._v(" "),_("p",[t._v("绝对长度单位是固定的，用任何一个绝对长度表示的长度都将恰好显示为这个尺寸。")]),t._v(" "),_("p",[t._v("不建议在屏幕上使用绝对长度单位，因为屏幕尺寸变化很大。但是，如果已知输出介质，则可以使用它们，例如用于打印布局（print layout）。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[t._v("单位")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("描述")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("cm")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("厘米")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("mm")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("毫米")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("in")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("英寸 (1in = 96px = 2.54cm)")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("px *")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("像素 (1px = 1/96th of 1in)")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("pt")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("点 (1pt = 1/72 of 1in)")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("pc")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("派卡 (1pc = 12 pt)")])])])]),t._v(" "),_("h3",{attrs:{id:"相对长度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#相对长度"}},[t._v("#")]),t._v(" 相对长度")]),t._v(" "),_("p",[t._v("相对长度单位规定相对于另一个长度属性的长度。相对长度单位在不同渲染介质之间缩放表现得更好。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[t._v("单位")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("描述")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("em")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("相对于元素的字体大小（font-size）（2em 表示当前字体大小的 2 倍）")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("ex")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("相对于当前字体的 x-height(极少使用)")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("ch")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v('相对于 "0"（零）的宽度')])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("rem")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("相对于根元素的字体大小（font-size）")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("vw")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("相对于视口*宽度的 1%")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("vh")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("相对于视口*高度的 1%")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("vmin")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("相对于视口*较小尺寸的 1％")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("vmax")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("相对于视口*较大尺寸的 1％")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("%")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("相对于父元素")])])])]),t._v(" "),_("blockquote",[_("p",[t._v("提示：em 和 rem 单元可用于创建完美的可扩展布局！"),_("br"),t._v("\n视口（Viewport）= 浏览器窗口的尺寸。如果视口宽 50 cm，则 1vw = 0.5cm。")])]),t._v(" "),_("h2",{attrs:{id:"页面导入样式时-使用link和-import有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#页面导入样式时-使用link和-import有什么区别"}},[t._v("#")]),t._v(" 页面导入样式时，使用link和@import有什么区别")]),t._v(" "),_("p",[_("strong",[t._v("1.从属关系区别")]),t._v(" "),_("code",[t._v("@import")]),t._v("是 CSS 提供的语法规则，只有导入样式表的作用；"),_("code",[t._v("link")]),t._v("是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。")]),t._v(" "),_("p",[_("strong",[t._v("2.加载顺序区别")]),t._v("\n加载页面时，"),_("code",[t._v("link")]),t._v("标签引入的 CSS 被同时加载；"),_("code",[t._v("@import")]),t._v("引入的 CSS 将在页面加载完毕后被加载。")]),t._v(" "),_("p",[_("strong",[t._v("3.兼容性区别")]),t._v(" "),_("code",[t._v("@import")]),t._v("是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；"),_("code",[t._v("link")]),t._v("标签作为 HTML 元素，不存在兼容性问题。")]),t._v(" "),_("p",[_("strong",[t._v("4.DOM可控性区别")]),t._v("\n可以通过 JS 操作 DOM ，插入"),_("code",[t._v("link")]),t._v("标签来改变样式；由于 DOM 方法是基于文档的，无法使用"),_("code",[t._v("@import")]),t._v("的方式插入样式。")]),t._v(" "),_("p",[_("strong",[t._v("5.权重区别(该项有争议，下文将详解)")]),t._v(" "),_("code",[t._v("link")]),t._v("引入的样式权重大于"),_("code",[t._v("@import")]),t._v("引入的样式。")]),t._v(" "),_("p",[_("strong",[t._v("结论")])]),t._v(" "),_("p",[t._v("就结论而言，强烈建议使用"),_("code",[t._v("link")]),t._v("标签，慎用"),_("code",[t._v("@import")]),t._v("方式。\n这样可以避免考虑"),_("code",[t._v("@import")]),t._v("的语法规则和注意事项，避免产生资源文件下载顺序混乱和http请求过多的烦恼。")]),t._v(" "),_("h2",{attrs:{id:"title与h1的区别、b与strong的区别、i与em的区别、title与alt的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#title与h1的区别、b与strong的区别、i与em的区别、title与alt的区别"}},[t._v("#")]),t._v(" title与h1的区别、b与strong的区别、i与em的区别、title与alt的区别")]),t._v(" "),_("p",[_("strong",[t._v("title与h1的区别")])]),t._v(" "),_("p",[t._v("定义：")]),t._v(" "),_("p",[t._v("title是网站标题，")]),t._v(" "),_("p",[t._v("h1是文章主题")]),t._v(" "),_("p",[t._v("作用：")]),t._v(" "),_("p",[t._v("title概括网站信息，可以直接告诉搜索引擎和用户这 个网站是关于什么主题和内容的，是显示在网页Tab栏里的；")]),t._v(" "),_("p",[t._v("h1突出文章主题，面对用户，更突出其视觉效果，指向 页面主体信息，是显示在网页中的。")]),t._v(" "),_("p",[_("strong",[t._v("b与strong的区别")])]),t._v(" "),_("p",[t._v("定义：")]),t._v(" "),_("p",[t._v("b(bold)是实体标签，用来给文字加粗，")]),t._v(" "),_("p",[t._v("strong是逻辑标签，作用是加强字符语气。")]),t._v(" "),_("p",[t._v("区别：")]),t._v(" "),_("p",[t._v("b标签只是加粗的样式，没有实际含义，常用来表达无强调或着重意味的粗体文字，比如文章摘要中的关键词、 评测文章中的产品名称、文章的导言；")]),t._v(" "),_("p",[t._v("strong表示标签内字符重要，用以强调，其默认格式是加粗，但是可以通 过CSS添加样式，使用别的样式强调。")]),t._v(" "),_("p",[t._v("建议：为了符合CSS3的规范，b应尽量少用而改用strong")]),t._v(" "),_("p",[_("strong",[t._v("i与em的区别")])]),t._v(" "),_("p",[t._v("定义：")]),t._v(" "),_("p",[t._v("i(italic)是实体标签，用来使字符倾斜，")]),t._v(" "),_("p",[t._v("em(emphasis)是逻辑标签，作用是强调文本内容")]),t._v(" "),_("p",[t._v("区别：")]),t._v(" "),_("p",[t._v("i标签只是斜体的样式，没有实际含义，常用来表达无强调或着重意味的斜体，比如生物学名、术语、外来语；")]),t._v(" "),_("p",[t._v("em表示标签内字符重要，用以强调，其默认格式是斜体，但是可以通过CSS添加样式。")]),t._v(" "),_("p",[t._v("建议：为了符合CSS3的规 范，i应尽量少用而改用em")]),t._v(" "),_("p",[_("strong",[t._v("title与alt的区别")])]),t._v(" "),_("p",[t._v("​\t\ttitle： 鼠标移入到图片显示的值")]),t._v(" "),_("p",[t._v("​\t\talt： 图片无法加载时显示的值")]),t._v(" "),_("p",[t._v("在SEO层面上，蜘蛛抓取不到图片的内容，所以前端在写img标签的时候为了增加SEO效果要加入alt属性来描述这张图是什么内容或者关键字")]),t._v(" "),_("h2",{attrs:{id:"css哪些属性不可以继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css哪些属性不可以继承"}},[t._v("#")]),t._v(" CSS哪些属性不可以继承")]),t._v(" "),_("p",[t._v("1、display")]),t._v(" "),_("p",[t._v("3、盒子模型的属性:宽度、高度、内外边距、边框等")]),t._v(" "),_("p",[t._v("4、背景属性：背景图片、颜色、位置等")]),t._v(" "),_("p",[t._v("5、定位属性：浮动、清除浮动、定位position等")]),t._v(" "),_("p",[t._v("6、生成内容属性:content、counter-reset、counter-increment")]),t._v(" "),_("p",[t._v("7、轮廓样式属性:outline-style、outline-width、outline-color、outline")]),t._v(" "),_("p",[t._v("8、页面样式属性:size、page-break-before、page-break-after")]),t._v(" "),_("h2",{attrs:{id:"css优先级比较"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css优先级比较"}},[t._v("#")]),t._v(" CSS优先级比较")]),t._v(" "),_("p",[t._v("!important > 内联样式 > id > class>标签 >通配")]),t._v(" "),_("p",[t._v("权重等级划分：")]),t._v(" "),_("p",[t._v("内联样式                                                                                 权重值： 1000")]),t._v(" "),_("p",[t._v("id选择器                                                                                  权重值：100")]),t._v(" "),_("p",[t._v("类、伪类、属性选择器                                                           权重值： 10")]),t._v(" "),_("p",[t._v("标签、伪元素                                                                           权重值： 1")]),t._v(" "),_("p",[t._v("通配(*)、子选择器(>)、相邻选择器(+)、等选择器                权重值： 0             后者覆盖前者")]),t._v(" "),_("h2",{attrs:{id:"清除浮动有哪些方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#清除浮动有哪些方式"}},[t._v("#")]),t._v(" 清除浮动有哪些方式")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("触发BFC，如使用 overflow：hidden")])]),t._v(" "),_("li",[_("p",[t._v("使用 ::after 伪元素")]),t._v(" "),_("div",{staticClass:"language-css extra-class"},[_("pre",{pre:!0,attrs:{class:"language-css"}},[_("code",[_("span",{pre:!0,attrs:{class:"token selector"}},[t._v("ul::after")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("content")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("display")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("block"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("clear")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("both"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n")])])])])]),t._v(" "),_("p",[t._v("3.多创建一个盒子，添加样式        clear： both；")]),t._v(" "),_("h2",{attrs:{id:"display-none-与visibility-hidden的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#display-none-与visibility-hidden的区别"}},[t._v("#")]),t._v(" display:none;与visibility：hidden的区别")]),t._v(" "),_("p",[t._v("很多前端的同学认为visibility: hidden和display: none的区别仅仅在于display: none隐藏后的元素不占据任何空间，而visibility: hidden隐藏后的元素空间依旧保留 ，实际上没那么简单，visibility是一个非常有故事性的属性")]),t._v(" "),_("p",[t._v("1、visibility具有继承性，给父元素设置visibility:hidden;子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别")]),t._v(" "),_("p",[t._v("2、visibility: hidden不会影响计数器的计数，如图所示，visibility: hidden虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样")]),t._v(" "),_("h2",{attrs:{id:"opacity和rgba的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#opacity和rgba的区别"}},[t._v("#")]),t._v(" opacity和rgba的区别")]),t._v(" "),_("p",[t._v("首先这两个都与透明度有关，那么他们之间有什么具体的区别呢？在实际工作中我们需要注意什么呢？")]),t._v(" "),_("ul",[_("li",[t._v("rgba只是背景颜色有透明效果")]),t._v(" "),_("li",[t._v("而有opacity属性元素的后代都会继承这个透明属性，包括但不限于文字图片等")])]),t._v(" "),_("h2",{attrs:{id:"meta标签"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#meta标签"}},[t._v("#")]),t._v(" meta标签")]),t._v(" "),_("p",[t._v("<meta> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。")]),t._v(" "),_("p",[t._v("<meta> 标签位于文档的头部，不包含任何内容。<meta> 标签的属性定义了与文档相关联的名称/值对。")]),t._v(" "),_("hr"),t._v(" "),_("p",[t._v("常见的meta标签总结")]),t._v(" "),_("p",[t._v("\x3c!-- 关键字，搜所引擎 SEO --\x3e")]),t._v(" "),_("p",[t._v('<meta http-equiv="keywords" content="关键字1,关键字2,...">')]),t._v(" "),_("p",[t._v("\x3c!-- 页面描述 --\x3e")]),t._v(" "),_("p",[t._v('<meta http-equiv="description" content="网页描述">')]),t._v(" "),_("p",[t._v("\x3c!-- content的取值为webkit,ie-comp,ie-stand之一，区分大小写，分别代表用webkit内核，IE兼容内核，IE标准内核。 --\x3e")]),t._v(" "),_("p",[t._v('<meta name="renderer" content="webkit|ie-comp|ie-stand">')]),t._v(" "),_("p",[t._v("\x3c!-- 若页面需默认用极速核，增加标签： --\x3e")]),t._v(" "),_("p",[t._v('<meta name="renderer" content="webkit">')]),t._v(" "),_("p",[t._v("\x3c!-- 若页面需默认用ie兼容内核，增加标签： --\x3e")]),t._v(" "),_("p",[t._v('<meta name="renderer" content="ie-comp">\n\x3c!-- 若页面需默认用ie标准内核，增加标签： --\x3e')]),t._v(" "),_("p",[t._v('<meta name="renderer" content="ie-stand">')]),t._v(" "),_("p",[t._v("\x3c!-- 如果安装了GCF，则使用GCF来渲染页面，如果没有安装GCF，则使用最高版本的IE内核进行渲染。X-UA-Compatible：这是个是IE8的专用标记,用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式(比如人见人烦的IE6)，以此来解决部分兼容问题。 --\x3e")]),t._v(" "),_("p",[t._v('<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" >')]),t._v(" "),_("p",[t._v("\x3c!-- 强制页面在当前窗口以独立页面显示。 --\x3e")]),t._v(" "),_("p",[t._v('<meta http-equiv="Window-target" content="_top">\n\x3c!-- 自动刷新，并指向新的页面 --\x3e')]),t._v(" "),_("p",[t._v('<meta http-equiv="Refresh" content="2；URL=http://">')]),t._v(" "),_("p",[t._v("\x3c!-- 禁止浏览器缓存 --\x3e")]),t._v(" "),_("p",[t._v("\x3c!-- 是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出用法： --\x3e")]),t._v(" "),_("p",[t._v('<meta http-equiv="pragram" content="no-cache">')]),t._v(" "),_("p",[t._v("\x3c!-- 清除缓存（再访问这个网站要重新下载！） --\x3e")]),t._v(" "),_("p",[t._v('<meta http-equiv="cache-control" content="no-cache, must-revalidate">')]),t._v(" "),_("p",[t._v("\x3c!-- 设定网页的到期时间 --\x3e")]),t._v(" "),_("p",[t._v('<meta http-equiv="expires" content="0">')]),t._v(" "),_("p",[t._v("\x3c!-- 手机端 --\x3e")]),t._v(" "),_("p",[t._v('<meta name="format-detection" content="telphone=no, email=no"/>')]),t._v(" "),_("p",[t._v("\x3c!-- 忽略页面中的数字识别为电话，忽略email识别 --\x3e")]),t._v(" "),_("p",[t._v('<meta name="apple-mobile-web-app-status-bar-style" content="black"/>')]),t._v(" "),_("p",[t._v("\x3c!-- 设置苹果工具栏颜色 --\x3e")]),t._v(" "),_("p",[t._v("\x3c!-- 不让百度转码 --\x3e")]),t._v(" "),_("p",[t._v('<meta http-equiv="Cache-Control" content="no-siteapp" />')]),t._v(" "),_("p",[t._v("\x3c!-- 不缓存 --\x3e")]),t._v(" "),_("p",[t._v('<meta http-equiv="cache-control" content="no-cache" />')]),t._v(" "),_("p",[t._v("\x3c!-- 初始化设备 --\x3e")]),t._v(" "),_("p",[t._v('<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui" />')]),t._v(" "),_("p",[t._v("\x3c!-- 网站开启对iphone私有 web app 程序的支持 --\x3e")]),t._v(" "),_("p",[t._v('<meta content="yes" name="apple-mobile-web-app-capable" />')]),t._v(" "),_("p",[t._v("\x3c!-- 改变顶部状态条的颜色 iphone私有的属性--\x3e")]),t._v(" "),_("p",[t._v('<meta content="black" name="apple-mobile-web-app-status-bar-style" />')]),t._v(" "),_("h2",{attrs:{id:"doctype标签"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#doctype标签"}},[t._v("#")]),t._v(" DOCTYPE标签")]),t._v("\n<!DOCTYPE> 声明位于文档中的最前面的位置，处于 标签 之前。\n<!DOCTYPE> 声明不是一个 HTML 标签；它是用来告知 Web 浏览器页面使用了哪种 HTML 版本。\n"),_("p",[t._v("在 HTML 4.01 中，<!DOCTYPE> 声明需引用 DTD （文档类型声明），因为 HTML 4.01 是基于 SGML （Standard Generalized Markup Language 标准通用标记语言）。DTD 指定了标记语言的规则，确保了浏览器能够正确的渲染内容。")]),t._v(" "),_("p",[t._v("HTML5 不是基于 SGML，因此不要求引用 DTD。")]),t._v(" "),_("p",[t._v("**提示：**总是给您的 HTML 文档添加 <!DOCTYPE> 声明，确保浏览器能够预先知道文档类型。")]),t._v(" "),_("h2",{attrs:{id:"script标签的defer和async"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#script标签的defer和async"}},[t._v("#")]),t._v(" script标签的defer和async")]),t._v(" "),_("p",[t._v("如果script标签中没有defer或async属性，浏览器在渲染中遇到script标签就会停止渲染，下载执行js代码，等待JS执行完毕后，浏览器再从中断的地方恢复渲染。这就会造成浏览器阻塞，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性，异步加载script。")]),t._v(" "),_("p",[_("strong",[t._v("defer （延迟执行）"),_("code",[t._v('<script defer src="script.js"><\/script>')])])]),t._v(" "),_("p",[t._v("defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，如果有多个defer的script标签，会按顺序执行，然后触发 DOMContentLoaded 事件。")]),t._v(" "),_("p",[_("strong",[t._v("async （异步加载）"),_("code",[t._v('<script async src="script.js"><\/script>')])])]),t._v(" "),_("p",[t._v("async属性表示异步执行引入的 JavaScript，即javaScript下载时html并未停止解析，等到javaScript下载完成，html就停止解析，执行javaScript代码，等待javaScript执行完毕，浏览器再继续渲染。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。如果有多个js脚本，哪个先下载完成就先执行哪个，跟书写顺序没有关系。")]),t._v(" "),_("h2",{attrs:{id:"伪类和伪元素"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#伪类和伪元素"}},[t._v("#")]),t._v(" 伪类和伪元素")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("其中伪类和伪元素的根本区别在于："),_("strong",[t._v("它们是否创造了新的元素。")])]),t._v(" "),_("p",[t._v("伪元素/伪对象：不存在在DOM文档中，是虚拟的元素，是创建新元素。代表某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。")])]),t._v(" "),_("li",[_("p",[t._v("在CSS3中，伪类与伪元素在语法上也有所区别，伪元素修改为以"),_("code",[t._v("::")]),t._v("开头。但因为历史原因，浏览器对以"),_("code",[t._v(":")]),t._v("开头的伪元素也继续支持，但建议规范书写为"),_("code",[t._v("::")]),t._v("开头。 为了方便区分")]),t._v(" "),_("ul",[_("li",[t._v("伪类只能使用“：”")]),t._v(" "),_("li",[t._v("而伪元素既可以使用“:”，也可以使用“::”")])])]),t._v(" "),_("li",[_("p",[t._v("伪对象要配合content属性一起使用\n伪对象不会出现在DOM中，所以不能通过js来操作，仅仅是在 CSS 渲染层加入\n伪对象的特效通常要使用:hover伪类样式来激活")])])]),t._v(" "),_("ul",[_("li",[_("p",[t._v(": 是伪类")])]),t._v(" "),_("li",[_("p",[t._v(":: 是伪元素")])])]),t._v(" "),_("h2",{attrs:{id:"object-fit"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#object-fit"}},[t._v("#")]),t._v(" object-fit")]),t._v(" "),_("p",[_("strong",[_("code",[t._v("object-fit")])]),t._v(" CSS属性指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。")]),t._v(" "),_("h3",{attrs:{id:"取值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#取值"}},[t._v("#")]),t._v(" 取值")]),t._v(" "),_("ul",[_("li",[_("p",[_("code",[t._v("contain")])]),t._v(" "),_("p",[t._v("被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。整个对象在填充盒子的同时保留其长宽比，因此如果宽高比与框的宽高比不匹配，该对象将被添加“"),_("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E9%BB%91%E9%82%8A",target:"_blank",rel:"noopener noreferrer"}},[t._v("黑边"),_("OutboundLink")],1),t._v("”。")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("cover")])]),t._v(" "),_("p",[t._v("被替换的内容在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框。")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("fill")])]),t._v(" "),_("p",[t._v("被替换的内容正好填充元素的内容框。整个对象将完全填充此框。如果对象的宽高比与内容框不相匹配，那么该对象将被拉伸以适应内容框。")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("none")])]),t._v(" "),_("p",[t._v("被替换的内容将保持其原有的尺寸。")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("scale-down")])]),t._v(" "),_("p",[t._v("内容的尺寸与 "),_("code",[t._v("none")]),t._v(" 或 "),_("code",[t._v("contain")]),t._v(" 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。")])])]),t._v(" "),_("h2",{attrs:{id:"怎么让chrome浏览器支持16px以下的文字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#怎么让chrome浏览器支持16px以下的文字"}},[t._v("#")]),t._v(" 怎么让chrome浏览器支持16px以下的文字")]),t._v(" "),_("p",[t._v("css\nchrome默认字体大小为16px\n采用CSS3缩放来实现更小的字体\nspan{\ndisplay: inline-block;\n-webkit-transform: scale(0.8);\n}")]),t._v(" "),_("h2",{attrs:{id:"css实现展开下文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css实现展开下文"}},[t._v("#")]),t._v(" css实现展开下文")]),t._v(" "),_("p",[t._v("HTML部分讲解：给内容部分前面加一个复选框控件（想要实现展开后能收回，一定要用复选框哦），后面加一个label标签，label通过复选框的id进行关联，当点击label时会选中复选框控件，可在CSS中通过伪类选择器:checked对其选中后的状态进行控制（取消选中当然就收回啦）~")]),t._v(" "),_("p",[t._v("CSS部分讲解：首先给内容部分设置一个固定高度和overflow: hidden，隐藏一部分文字；然后设置当控件被选中后内容部分height: auto，实现展开，并且将箭头旋转180度，展现出可收回状态；最后要记得把复选框控件隐藏掉哦（毕竟影响布局23333），效果相当完美诶~")]),t._v(" "),_("h2",{attrs:{id:"xhtml和html的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#xhtml和html的区别"}},[t._v("#")]),t._v(" xhtml和html的区别")]),t._v(" "),_("p",[t._v("XHTML代表可扩展超文本标记语言。它是HTML和XML语言之间的交叉。")]),t._v(" "),_("p",[t._v("XHTML几乎与HTML相同，但它比HTML更严格。XHTML是HTML定义为XML应用程序。它受到所有主流浏览器的支持。")]),t._v(" "),_("p",[_("strong",[t._v("HTML和XHTML之间的区别")]),_("br"),t._v("\n尽管XHTML与HTML几乎相同，但正确创建代码更为重要，因为XHTML在语法和区分大小写方面比HTML更严格严谨。XHTML文档是格式良好的，并使用标准XML解析器进行解析，这与HTML不同，HTML需要宽松的HTML特定解析器。")]),t._v(" "),_("p",[t._v("总的来说，与HTML相比，XHTML发生了一些变化，有了一下差异。这些变化可分为三个部分："),_("br"),t._v("\n文档结构的变化")]),t._v(" "),_("p",[t._v("1、所有文件都必须有DOCTYPE。")]),t._v(" "),_("p",[t._v("2、"),_("code",[t._v("<html>")]),t._v("中的xmlns属性是必需的，必须为文档指定xml命名空间。")]),t._v(" "),_("p",[t._v("3、"),_("code",[t._v("<html>，<head>，<title>")]),t._v("和"),_("code",[t._v("<body>")]),t._v("对于各自的结束标记是必需的。")]),t._v(" "),_("p",[t._v("XHTML标签的变化")]),t._v(" "),_("p",[t._v("1、所有的XHTML标签必须为小写。")]),t._v(" "),_("p",[t._v("2、必须要结束所有XHTML标记，即要结束</>标签。例："),_("code",[t._v("<h1></h1>，<hr/>，<img/>")])]),t._v(" "),_("p",[t._v("3、必须正确嵌套所有XHTML标记，标签的嵌套顺序要正确。")]),t._v(" "),_("p",[t._v("4、XHTML文档必须有一个根元素。")]),t._v(" "),_("p",[t._v("XHTML属性的变化")]),t._v(" "),_("p",[t._v("1、必须正确添加所有XHTML属性。")]),t._v(" "),_("p",[t._v("2、所有XHTML属性必须为小写，且必须加上引号。")]),t._v(" "),_("p",[t._v("2、XHTML属性不能被缩写。")]),t._v(" "),_("p",[t._v("3、必须引用XHTML属性值。")]),t._v(" "),_("h2",{attrs:{id:"浏览器的标准模式、怪异模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的标准模式、怪异模式"}},[t._v("#")]),t._v(" 浏览器的标准模式、怪异模式")]),t._v(" "),_("p",[t._v("在W3C标准未确定之前，各浏览器对于HTML和CSS有各自不同的解析方式，很多旧网页都是在W3C标准未确定时期实现、设计的。在W3C标准确定之后，浏览器为了保证对非标准的旧网页设计的后向兼容性。现代浏览器（IE6以上，IE6以下版本永远定在了怪异模式）一般都有两种渲染模式：标准模式和怪异模式。")]),t._v(" "),_("p",[t._v("在标准模式下，浏览器按照W3C标准对文档进行解析和渲染；而在怪异模式下，浏览器则按照非标准的实现方式对文档进行解析和渲染。这样的话，对于旧有的网页，浏览器启动怪异模式，就能够使得旧网页正常显示。"),_("br"),t._v(" "),_("strong",[t._v("开启怪异模式")]),_("br"),t._v("\n没有指定dtd将会开启浏览器的怪异模式，这种说法是错的！正确的说法应该是没有定义doctype才会开启怪异模式。")]),t._v(" "),_("p",[t._v("在标准化之前写的页面是没有doctype的，因此没有doctype的页面是在怪异模式下渲染的。"),_("br"),t._v("\n如果web开发人员加入的doctype，大部分的doctype会开启标准模式，页面也会按照标准来渲染。  "),_("br"),t._v(" "),_("strong",[t._v("标准模式与怪异模式区别")]),_("br"),t._v("\n盒模型宽高：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("在怪异模式下，盒模型为怪异盒模型 ，宽高包含padding和border；")])]),t._v(" "),_("li",[_("p",[t._v("在标准模式下，盒模型为标准盒子模型，宽高为内容宽高不包含padding和border；")])])]),t._v(" "),_("p",[t._v("图片垂直对齐方式")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("对于行内元素和table-cell元素，标准模式下vertical-align属性默认值是baseline；")])]),t._v(" "),_("li",[_("p",[t._v("在怪异模式下，table单元格中的图片的vertical-align属性默认值是bottom，因此在图片底部会有几像素的空间；")])])]),t._v(" "),_("p",[t._v("元素中的字体")]),t._v(" "),_("ul",[_("li",[t._v("css中font的属性都是可以继承的；")]),t._v(" "),_("li",[t._v("怪异模式下，对于table元素，字体的某些元素不能从其他封装元素继承中得到，特别是font-size属性")])]),t._v(" "),_("p",[t._v("内联元素的尺寸")]),t._v(" "),_("ul",[_("li",[t._v("标准模式下，non-replaced inline元素无法自定义大写；")]),t._v(" "),_("li",[t._v("怪异模式下，定义元素的宽高会影响元素的尺寸；")])]),t._v(" "),_("p",[t._v("元素的百分比高度")]),t._v(" "),_("ul",[_("li",[t._v("当一个元素使用百分比高度时，在标准模式下，高度取决于内容变化；")]),t._v(" "),_("li",[t._v("在怪异迷失下，百分比被准确应用；")])]),t._v(" "),_("p",[t._v("元素溢出的处理")]),t._v(" "),_("ul",[_("li",[t._v("标准模式下，overflow取值默认值为visible；")]),t._v(" "),_("li",[t._v("在怪异模式下，这个溢出会被当做扩展box对待，就是元素的大小由内容决定，溢出不会裁剪，元素框自动调整，包含溢出内容；")])]),t._v(" "),_("h2",{attrs:{id:"ie6中的常见bug与相应的解决办法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ie6中的常见bug与相应的解决办法"}},[t._v("#")]),t._v(" IE6中的常见BUG与相应的解决办法")]),t._v(" "),_("p",[t._v("一、IE6双倍边距bug")]),t._v(" "),_("p",[t._v("当页面上的元素使用float浮动时，不管是向左还是向右浮动；只要该元素带有margin像素都会使该值乘以2，例如“margin-left:10px” 在IE6中，该值就会被解析为20px。想要解决这个BUG就需要在该元素中加入display:inline 或 display:block 明确其元素类型即可解决双倍边距的BUG")]),t._v(" "),_("p",[t._v("二、IE6中3像素问题及解决办法")]),t._v(" "),_("p",[t._v("当元素使用float浮动后，元素与相邻的元素之间会产生3px的间隙。诡异的是如果右侧的容器没设置高度时3px的间隙在相邻容器的内部，当设定高度后又跑到容器的相反侧了。要解决这类BUG的话，需要使布局在同一行的元素都加上float浮动。")]),t._v(" "),_("p",[t._v("三、IE6中奇数宽高的BUG")]),t._v(" "),_("p",[t._v("IE6中奇数的高宽显示大小与偶数高宽显示大小存在一定的不同。其中要问题是出在奇数高宽上。要解决此类问题，只需要尽量将外部定位的div高宽写成偶数即可。")]),t._v(" "),_("p",[t._v("四、IE6中图片链接的下方有间隙")]),t._v(" "),_("p",[t._v("IE6中图片的下方会存在一定的间隙，尤其在图片垂直挨着图片的时候，即可看到这样的间隙。要解决此类问题，需要将img标签定义为display:block 或定义vertical-align对应的属性。也可以为img对应的样式写入font-size:0")]),t._v(" "),_("p",[t._v("五、IE6下空元素的高度BUG")]),t._v(" "),_("p",[t._v("如果一个元素中没有任何内容，当在样式中为这个元素设置了0-19px之间的高度时。此元素的高度始终为19px。")]),t._v(" "),_("p",[t._v("解决的方法有四种:")]),t._v(" "),_("p",[t._v("1.在元素的css中加入：overflow:hidden")]),t._v(" "),_("p",[t._v("2.在元素中插入html注释：\x3c!-- >")]),t._v(" "),_("p",[t._v("3.在元素中插入html的空白符： ")]),t._v(" "),_("p",[t._v("4.在元素的css中加入：font-size:0")]),t._v(" "),_("p",[t._v("六、重复文字的BUG")]),t._v(" "),_("p",[t._v("在某些比较复杂的排版中，有时候浮动元素的最后一些字符会出现在clear清除元素的下面。")]),t._v(" "),_("p",[t._v("解决方法如下：")]),t._v(" "),_("p",[t._v("1.确保元素都带有display:inline")]),t._v(" "),_("p",[t._v("2.在最后一个元素上使用“margin-right:-3px")]),t._v(" "),_("p",[t._v("3.为浮动元素的最后一个条目加上条件注释，<!–[if !IE]>xxx<![endif]–>")]),t._v(" "),_("p",[t._v("4.在容器的最后元素使用一个空白的div，为这个div指定不超过容器的宽度。")]),t._v(" "),_("p",[t._v("七、IE6中 z-index失效")]),t._v(" "),_("p",[t._v("具体BUG为，元素的父级元素设置的z-index为1，那么其子级元素再设置z-index时会失效，其层级会继承父级元素的设置，造成某些层级调整上的BUG。详细解释可以阅读IE6中部分情况下z-index无效的原因，以及解决办法")]),t._v(" "),_("p",[t._v("结语：实际上IE6中，很多BUG的解决方法都可以使用display:inline、font-size:0、float解决。因此我们在书写代码时要记住，一旦使用了float浮动，就为元素增加一个display:inline样式，可以有效的避免浮动造成的样式错乱问题。使用空DIV时，为了避免其高度影响布局美观，也可以为其加上font-size:0 这样就很容易避免一些兼容上的问题。")])])}),[],!1,null,null,null);v.default=a.exports}}]);