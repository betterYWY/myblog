(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{617:function(t,e,v){"use strict";v.r(e);var a=v(5),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"computed-和-watch-有什么异同"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-有什么异同"}},[t._v("#")]),t._v(" computed 和 watch 有什么异同")]),t._v(" "),v("p",[v("strong",[t._v("相同点:")])]),t._v(" "),v("ul",[v("li",[v("code",[t._v("计算属性")]),t._v("和"),v("code",[t._v("监听属性")]),t._v(", 本质上都是一个watcher实例, 它们都通过"),v("strong",[t._v("响应式系统")]),t._v("与数据,页面建立通信.")])]),t._v(" "),v("p",[v("strong",[t._v("不同点")])]),t._v(" "),v("ul",[v("li",[v("code",[t._v("计算属性")]),t._v('带有"懒计算"的功能, 为什么我不说是缓存呢? 后面你就知道了.')]),t._v(" "),v("li",[t._v("监听的逻辑有差异. 这一点从使用时就特别明显, "),v("code",[t._v("监听属性")]),t._v("是目标值变了,它去执行函数.而"),v("code",[t._v("计算属性")]),t._v("是函数的值变了, 它重新求值.")]),t._v(" "),v("li",[t._v("页面刷新以后, 计算属性会默认立即执行, 而watch属性则需要我们自己配置")])]),t._v(" "),v("p",[t._v("如果一个值依赖多个属性（多对一），用computed肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用watch更加方便一些。")]),t._v(" "),v("p",[t._v("watch 支持异步代码而 computed 不支持。")]),t._v(" "),v("h2",{attrs:{id:"直接给一个数组项赋值-vue-能检测到变化吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#直接给一个数组项赋值-vue-能检测到变化吗"}},[t._v("#")]),t._v(" 直接给一个数组项赋值，Vue 能检测到变化吗？")]),t._v(" "),v("p",[t._v("由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：")]),t._v(" "),v("ul",[v("li",[t._v("当你利用索引直接设置一个数组项时，例如： vm.items[indexOfItem] = newValue")]),t._v(" "),v("li",[t._v("当你修改数组的长度时，例如： vm.items.length = newLength")])]),t._v(" "),v("p",[t._v("为了解决第一个问题，Vue 提供了以下操作方法：\n通过索引来修改数组，使其能成为响应式，解决直接使用赋值不能响应的问题")]),t._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[t._v("Vue"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v("'huanpu'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v("'name'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("    "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//对数组")]),t._v("\nVue"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("$set")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v("'K'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v("'V'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("　　"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//对对象")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//参数一表示要处理的数组名称。")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//参数二表示要处理的数组的索引。")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//参数三表示要处理的数组的值。")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//为了解决第二个问题，Vue 提供了以下操作方法：")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Array.prototype.splice")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//vm.items.splice(newLength)")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//newLength 就是指的你更新的长度")]),t._v("\n")])])]),v("blockquote",[v("p",[v("a",{attrs:{href:"https://blog.csdn.net/CKT0816/article/details/107705364",target:"_blank",rel:"noopener noreferrer"}},[t._v("转载于"),v("OutboundLink")],1)])]),t._v(" "),v("h2",{attrs:{id:"父组件和子组件之间的生命周期执行顺序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#父组件和子组件之间的生命周期执行顺序"}},[t._v("#")]),t._v(" 父组件和子组件之间的生命周期执行顺序")]),t._v(" "),v("p",[v("strong",[t._v("组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。 组件的销毁操作是先父后子，销毁完成的顺序是先子后父。")])]),t._v(" "),v("p",[t._v("加载渲染过程 子组件在父组件的beforeMount和Mounted之间渲染")]),t._v(" "),v("ul",[v("li",[t._v("执行顺序：父组件先创建，然后子组件创建；子组件先挂载，然后父组件挂载，即父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted")])]),t._v(" "),v("p",[t._v("子组件更新过程")]),t._v(" "),v("ul",[v("li",[t._v("父beforeUpdate->子beforeUpdate->子updated->父updated")])]),t._v(" "),v("p",[t._v("父组件更新过程")]),t._v(" "),v("ul",[v("li",[t._v("影响到子组件： - 父beforeUpdate -> 子beforeUpdate->子updated -> 父updted")]),t._v(" "),v("li",[t._v("不影响子组件： - 父beforeUpdate -> 父updated")])]),t._v(" "),v("p",[t._v("销毁过程")]),t._v(" "),v("ul",[v("li",[t._v("父beforeDestroy->子beforeDestroy->子destroyed->父destroyed")])]),t._v(" "),v("h2",{attrs:{id:"为什么组件中的data是一个函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么组件中的data是一个函数"}},[t._v("#")]),t._v(" 为什么组件中的data是一个函数")]),t._v(" "),v("p",[t._v("组件的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一分新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。")]),t._v(" "),v("h2",{attrs:{id:"异步请求在哪一步发起"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步请求在哪一步发起"}},[t._v("#")]),t._v(" 异步请求在哪一步发起？")]),t._v(" "),v("p",[t._v("可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data已经创建，可以将服务器端返回的数据进行赋值。\n如果异步请求不需要依赖 DOM 推荐加载 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：")]),t._v(" "),v("ul",[v("li",[t._v("能更快获取到服务端数据，减少页面loading时间；")]),t._v(" "),v("li",[t._v("ssr 不支持 beforeMount、mounted 钩子函数，所以放在 created 中有助于一致性。")])]),t._v(" "),v("h2",{attrs:{id:"怎样理解-vue-的单项数据流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#怎样理解-vue-的单项数据流"}},[t._v("#")]),t._v(" 怎样理解 Vue 的单项数据流")]),t._v(" "),v("p",[t._v("数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父组件的状态，从而导致你的应用的数据流向难以理解。"),v("br"),t._v("\n注意：在子组件直接用 v-model 绑定父组件传过来的 props 这样是不规范的写法，开发环境会报警告。"),v("br"),t._v("\n如果实在要改变父组件的 props 值可以再data里面定义一个变量，并用 prop 的值初始化它，之后用$emit 通知父组件去修改")]),t._v(" "),v("h2",{attrs:{id:"v-if-和-v-for-为什么不建议一起使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-for-为什么不建议一起使用"}},[t._v("#")]),t._v(" v-if 和 v-for 为什么不建议一起使用")]),t._v(" "),v("p",[t._v("v-for和v-if不要在同一标签中使用，因为解析时先解析v-for在解析v-if。如果遇到需要同时使用时可以考虑写成计算属性的方式。")]),t._v(" "),v("h2",{attrs:{id:"vue-2-0-响应式数据的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-2-0-响应式数据的原理"}},[t._v("#")]),t._v(" Vue 2.0 响应式数据的原理")]),t._v(" "),v("p",[t._v("整体思路是数据劫持 + 观察者模式"),v("br"),t._v("\n对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已存在的属性），数组则是通过重写数组来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存在它所依赖的 watcher （依赖收集）get，当属性变化后会通知自己对应的 watcher 去更新（派发更新）set。"),v("br"),t._v("\n1、Object.defineProperty 数据劫持"),v("br"),t._v("\n2、使用 getter 收集依赖 ，setter 通知 watcher派发更新。"),v("br"),t._v("\n3、watcher 发布订阅模式。")]),t._v(" "),v("h2",{attrs:{id:"vue-如何检测数组变化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-如何检测数组变化"}},[t._v("#")]),t._v(" Vue 如何检测数组变化")]),t._v(" "),v("p",[t._v("数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择对7种数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写（AOP 切片思想）。"),v("br"),t._v("\n所以在 Vue 中修改数组的索引和长度无法监控到。需要通过以上7种变异方法修改数组才会触发数组对应的watcher进行更新。")]),t._v(" "),v("h2",{attrs:{id:"使用过-vue-ssr-吗-说说-ssr"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用过-vue-ssr-吗-说说-ssr"}},[t._v("#")]),t._v(" 使用过 Vue SSR 吗？说说 SSR")]),t._v(" "),v("p",[t._v("SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。"),v("br"),t._v("\n优点：")]),t._v(" "),v("ul",[v("li",[t._v("SSR 有着更好的 SEO、并且首屏加载速度更快。"),v("br"),t._v("\n缺点：")]),t._v(" "),v("li",[t._v("开发条件会受限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。")]),t._v(" "),v("li",[t._v("服务器会有更大的负载需求。")])]),t._v(" "),v("h2",{attrs:{id:"vue-mixin-的使用场景和原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-mixin-的使用场景和原理"}},[t._v("#")]),t._v(" Vue.mixin 的使用场景和原理")]),t._v(" "),v("p",[t._v("在日常开发中，我们经常会遇到在不同组件中经常用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过vue 的 mixin 功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有相同名选项时，这些选项将以恰当的方式进行“合并”。")]),t._v(" "),v("h2",{attrs:{id:"vue-set-方法原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-set-方法原理"}},[t._v("#")]),t._v(" Vue.set 方法原理")]),t._v(" "),v("p",[t._v("了解 Vue 响应式原理的同学都知道在两种情况下修改 Vue 是不会触发视图更新的。"),v("br"),t._v("\n1、在实例创建之后添加新的属性到实例上（给响应式对象新增属性）"),v("br"),t._v("\n2、直接更改数组下标来修改数组的值。"),v("br"),t._v("\nVue.set 或者说是 $set 原理如下"),v("br"),t._v("\n因为响应式数据 我们给对象和数组本身新增了__ob__属性，代表的是 Observer 实例。当给对象新增不存在的属性，首先会把新的属性进行响应式跟踪 然后会触发对象 "),v("strong",[t._v("ob")]),t._v(" 的dep收集到的 watcher 去更新，当修改数组索引时我们调用数组本身的 splice 方法去更新数组。")]),t._v(" "),v("h2",{attrs:{id:"vue-extend-作用和原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-extend-作用和原理"}},[t._v("#")]),t._v(" Vue.extend 作用和原理")]),t._v(" "),v("p",[t._v("官方解释：Vue.extend 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。"),v("br"),t._v("\n其实就是一个子类构造器，是Vue组件的核心api。实现思路就是使用原型继承的方法返回了 vue 的子类，并且利用 mergeOptions 把传入组件的 options 就和父类的 options 进行了合并。")]),t._v(" "),v("h2",{attrs:{id:"vue-修饰符有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-修饰符有哪些"}},[t._v("#")]),t._v(" Vue 修饰符有哪些？")]),t._v(" "),v("p",[v("strong",[t._v("事件修饰符")])]),t._v(" "),v("ul",[v("li",[t._v(".stop 阻止事件继续传播")]),t._v(" "),v("li",[t._v(".prevent 阻止标签默认行为")]),t._v(" "),v("li",[t._v(".capture 使用事件捕获模式，即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理")]),t._v(" "),v("li",[t._v(".self 只当在 event.target 是当前元素自身时触发处理函数")]),t._v(" "),v("li",[t._v(".once 事件只会触发一次")]),t._v(" "),v("li",[t._v(".passive 告诉浏览器你不想阻止事件的默认行为")]),t._v(" "),v("li",[t._v("v-model 的修饰符")]),t._v(" "),v("li",[t._v(".lazy 通过这个修饰符，转变为在 change 事件再同步")]),t._v(" "),v("li",[t._v(".number 自动将用户输入值转化为数值类型")]),t._v(" "),v("li",[t._v(".trim 自动过滤用户输入的收尾空格"),v("br"),t._v(" "),v("strong",[t._v("键盘事件修饰符")])]),t._v(" "),v("li",[t._v(".enter")]),t._v(" "),v("li",[t._v(".tab")]),t._v(" "),v("li",[t._v(".delete (捕获“删除”和“退格”键)")]),t._v(" "),v("li",[t._v(".esc")]),t._v(" "),v("li",[t._v(".space")]),t._v(" "),v("li",[t._v(".up")]),t._v(" "),v("li",[t._v(".down")]),t._v(" "),v("li",[t._v(".left")]),t._v(" "),v("li",[t._v(".right"),v("br"),t._v(" "),v("strong",[t._v("系统修饰符")])]),t._v(" "),v("li",[t._v(".ctrl")]),t._v(" "),v("li",[t._v(".alt")]),t._v(" "),v("li",[t._v(".shift")]),t._v(" "),v("li",[t._v(".meta"),v("br"),t._v(" "),v("strong",[t._v("鼠标按钮修饰符")])]),t._v(" "),v("li",[t._v(".left")]),t._v(" "),v("li",[t._v(".right")]),t._v(" "),v("li",[t._v(".middle")])]),t._v(" "),v("h2",{attrs:{id:"vue模板编译原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue模板编译原理"}},[t._v("#")]),t._v(" vue模板编译原理")]),t._v(" "),v("p",[t._v("Vue 的编译过程就是将 template 转化为 render 函数的过程，分为以下三步："),v("br"),t._v("\n第一步是将 模板字符串转换成 element ASTs（解析器）"),v("br"),t._v("\n第二步是对 AST 进行静态节点标记，主要用来做虚拟 DOM 的渲染优化（优化器）"),v("br"),t._v("\n第三步是 使用element ASTs 生成 render 函数代码字符串（代码生成器）")])])}),[],!1,null,null,null);e.default=s.exports}}]);