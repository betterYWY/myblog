(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{619:function(e,a,r){"use strict";r.r(a);var l=r(5),v=Object(l.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"webpack-四个核心的概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webpack-四个核心的概念"}},[e._v("#")]),e._v(" Webpack 四个核心的概念")]),e._v(" "),r("p",[e._v("Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。")]),e._v(" "),r("p",[e._v("Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。")]),e._v(" "),r("p",[e._v("Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。")]),e._v(" "),r("p",[e._v("loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。")]),e._v(" "),r("p",[e._v("插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。")]),e._v(" "),r("p",[e._v("使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。")]),e._v(" "),r("h2",{attrs:{id:"webpack是干嘛的-定义-解释"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webpack是干嘛的-定义-解释"}},[e._v("#")]),e._v(" webpack是干嘛的？定义？解释？")]),e._v(" "),r("p",[e._v("webpack是一个打包工具，前端半自动化开发工具。它是基于nodejs运行的，它的功能有：压缩代码，压缩图片，解析es6,解析sass语法，代码热更新等。")]),e._v(" "),r("h2",{attrs:{id:"webpack构成部分"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webpack构成部分"}},[e._v("#")]),e._v(" webpack构成部分？")]),e._v(" "),r("p",[e._v("入口，出口，插件，装载机loader，本地服务devServer")]),e._v(" "),r("h2",{attrs:{id:"webpack执行过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webpack执行过程"}},[e._v("#")]),e._v(" webpack执行过程？")]),e._v(" "),r("p",[e._v("webpack默认执行webpack.config.js文件，读取入口文件开始解析各种资源。")]),e._v(" "),r("h2",{attrs:{id:"npm-run-build-serve-之后发生了什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#npm-run-build-serve-之后发生了什么"}},[e._v("#")]),e._v(" npm run build / serve 之后发生了什么？")]),e._v(" "),r("p",[e._v("脚手架使用webpack来执行配置文件，默认是webpack.config.js或者vue.config.js。然后执行入口文件的js,进行解析处理。"),r("br"),e._v("\n如果是build则生成物理文件存在磁盘上。如果是server的话则将编译的结果存入内存条中。")]),e._v(" "),r("h2",{attrs:{id:"列举几个常用loader"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#列举几个常用loader"}},[e._v("#")]),e._v(" 列举几个常用loader？")]),e._v(" "),r("ul",[r("li",[e._v("sass-loader 解析sass文件，转成css,")]),e._v(" "),r("li",[e._v("file-loader 处理字体，图片,")]),e._v(" "),r("li",[e._v("url-loader 基于file-loader处理文件,")]),e._v(" "),r("li",[e._v("css-loader 解析css文件，处理css代码,")]),e._v(" "),r("li",[e._v("style-loader把css代码插入到页面当中,")]),e._v(" "),r("li",[e._v("img-loader专门处理图片的，")]),e._v(" "),r("li",[e._v("babel-loader解析es6转成es5")])]),e._v(" "),r("h2",{attrs:{id:"loader的执行顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#loader的执行顺序"}},[e._v("#")]),e._v(" loader的执行顺序？")]),e._v(" "),r("p",[e._v("自下而上，从右向左")]),e._v(" "),r("h2",{attrs:{id:"plugins有哪些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#plugins有哪些"}},[e._v("#")]),e._v(" plugins有哪些？")]),e._v(" "),r("p",[e._v("html-webpack-plugins解析html的\ndefine-plugin：定义环境变量"),r("br"),e._v("\ncommons-chunk-plugin：提取公共代码"),r("br"),e._v("\nuglifyjs-webpack-plugin：通过UglifyES压缩ES6代码")]),e._v(" "),r("h2",{attrs:{id:"loader和插件plugins的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#loader和插件plugins的区别"}},[e._v("#")]),e._v(" loader和插件plugins的区别？")]),e._v(" "),r("p",[r("strong",[e._v("不同的作用")]),r("br"),e._v('\nLoader直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。'),r("br"),e._v('\nPlugin直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。\n'),r("strong",[e._v("不同的用法")]),r("br"),e._v("\nLoader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）"),r("br"),e._v("\nPlugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。")]),e._v(" "),r("h2",{attrs:{id:"webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全"}},[e._v("#")]),e._v(" webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全")]),e._v(" "),r("p",[e._v("Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：")]),e._v(" "),r("ol",[r("li",[e._v("初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；")]),e._v(" "),r("li",[e._v("开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；")]),e._v(" "),r("li",[e._v("确定入口：根据配置中的 entry 找出所有的入口文件；")]),e._v(" "),r("li",[e._v("编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；")]),e._v(" "),r("li",[e._v("完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；")]),e._v(" "),r("li",[e._v("输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；")]),e._v(" "),r("li",[e._v("输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。"),r("br"),e._v("\n在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。")])]),e._v(" "),r("h2",{attrs:{id:"是否写过loader和plugin-描述一下编写loader或plugin的思路"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#是否写过loader和plugin-描述一下编写loader或plugin的思路"}},[e._v("#")]),e._v(" 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？")]),e._v(" "),r("p",[e._v('Loader像一个"翻译官"把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。')]),e._v(" "),r("p",[e._v('编写Loader时要遵循单一原则，每个Loader只做一种"转义"工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。')]),e._v(" "),r("p",[e._v("相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。")]),e._v(" "),r("h2",{attrs:{id:"webpack的热更新是如何做到的-说明其原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webpack的热更新是如何做到的-说明其原理"}},[e._v("#")]),e._v(" webpack的热更新是如何做到的？说明其原理？")]),e._v(" "),r("p",[e._v("webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。")]),e._v(" "),r("ol",[r("li",[e._v("第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。")]),e._v(" "),r("li",[e._v("第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。")]),e._v(" "),r("li",[e._v("第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。")]),e._v(" "),r("li",[e._v("第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。")]),e._v(" "),r("li",[e._v("webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。")]),e._v(" "),r("li",[e._v("HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。")]),e._v(" "),r("li",[e._v("而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。")]),e._v(" "),r("li",[e._v("最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。")])]),e._v(" "),r("h2",{attrs:{id:"如何利用webpack来优化前端性能-提高性能和体验"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何利用webpack来优化前端性能-提高性能和体验"}},[e._v("#")]),e._v(" 如何利用webpack来优化前端性能？（提高性能和体验）")]),e._v(" "),r("p",[e._v("用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。"),r("br"),e._v("\n压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css"),r("br"),e._v("\n利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径"),r("br"),e._v("\n删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现"),r("br"),e._v("\n提取公共代码。")]),e._v(" "),r("h2",{attrs:{id:"如何提高webpack的构建速度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何提高webpack的构建速度"}},[e._v("#")]),e._v(" 如何提高webpack的构建速度？")]),e._v(" "),r("ul",[r("li",[e._v("多入口情况下，使用CommonsChunkPlugin来提取公共代码")]),e._v(" "),r("li",[e._v("通过externals配置来提取常用库")]),e._v(" "),r("li",[e._v("利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。")]),e._v(" "),r("li",[e._v("使用Happypack 实现多线程加速编译")]),e._v(" "),r("li",[e._v("使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度")]),e._v(" "),r("li",[e._v("使用Tree-shaking和Scope Hoisting来剔除多余代码")])]),e._v(" "),r("h2",{attrs:{id:"怎么配置单页应用-怎么配置多页应用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#怎么配置单页应用-怎么配置多页应用"}},[e._v("#")]),e._v(" 怎么配置单页应用？怎么配置多页应用？")]),e._v(" "),r("p",[e._v("单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述")]),e._v(" "),r("p",[e._v("多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：")]),e._v(" "),r("ul",[r("li",[e._v("每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表")]),e._v(" "),r("li",[e._v("随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置")])])])}),[],!1,null,null,null);a.default=v.exports}}]);