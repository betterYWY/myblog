(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{625:function(t,v,_){"use strict";_.r(v);var e=_(5),T=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"http协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http协议"}},[t._v("#")]),t._v(" HTTP协议")]),t._v(" "),_("p",[_("strong",[t._v("（1）什么是HTTP协议")]),_("br"),t._v("\nHTTP (HyperText Transfer Protocol，超文本传输协议) 是一种通信协议，是指计算机网络中两台计算机之间进行通信所必须共同遵守的规定或规则，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端，是互联网上应用最为广泛的一种网络协议。")]),t._v(" "),_("p",[_("strong",[t._v("（2）一种无状态协议")]),_("br"),t._v("\nHTTP协议是不保存状态的协议，即HTTP是无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过来的请求或响应都不做持久化处理。"),_("br"),t._v("\n使用HTTP协议，每当有新的请求发送时，就会有对应的新的响应产生。协议本身不保留之前一切的请求或响应报文的信息。也就是说，无法根据之前的状态进行本次请求的处理。"),_("br"),t._v("\n无状态优点： ①更快地处理大量事务，确保协议的可伸缩性。②由于不必保存状态，这就可以减少服务器的CPU及内存资源的消耗。"),_("br"),t._v("\nHTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。"),_("br"),t._v("\nCookie会根据从服务器端发送的响应报文类中的Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往服务器发送请求时，客户端会自动的请求报文中加入Cookie值后发送出去。服务器端接收到客户端发送过来的Cookie后，回去检查究竟是从哪一个客户端发来的请求，然后对比服务器上的记录，最后得到之前状态的信息。")]),t._v(" "),_("p",[_("strong",[t._v("（3）HTTP协议的报文")]),_("br"),t._v("\n用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的HTTP报文叫做响应报文。HTTP报文本身是由多行数据构成的字符串文本。"),_("br"),t._v("\nHTTP报文包括以下三部分：")]),t._v(" "),_("ol",[_("li",[t._v("报文首部"),_("br"),t._v("\n客户端或服务器端需处理的请求或响应的内容及属性。包括：请求行(包含用于请求的方法，请求URI，HTTP版本)，状态行(包含表明响应结果的状态码，原因短语，HTTP版本)，首部字段(包含表明请求和响应的各种条件和属性的各类首部)。")]),t._v(" "),_("li",[t._v("空行"),_("br"),t._v("\nCR+LF，CR(Crriage Return，回车符) 和 LF(Line Feed，换行符)。")]),t._v(" "),_("li",[t._v("报文主体"),_("br"),t._v("\n应被发送的数据。")])]),t._v(" "),_("p",[_("strong",[t._v("（4）HTTP持久化连接")])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("持久连接"),_("br"),t._v("\nHTTP协议的初始版本中，每进行一次HTTP通信就要断开一次"),_("RouterLink",{attrs:{to:"/网络相关问题.html#tcp三次握手"}},[t._v("TCP连接")]),t._v("，增加了通行量的开销。"),_("br"),t._v("\n为了解决上述TCP的问题，HTTP/1.1推出了持久连接（HTTP Persistent Connections，也称为HTTP keep-alive 或 HTTP connection reuse）的方法。"),_("br"),t._v("\n持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。"),_("br"),t._v("\n优点：减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面的显示速度就相应提高了。"),_("br"),t._v("\n在HTTP/1.1中，所有连接默认都是持久连接，但在HTTP/1.0内并未标准化。")],1)]),t._v(" "),_("li",[_("p",[t._v("管线化"),_("br"),t._v("\n持久连接使得多数请求以管线化方式发送成为可能。之前发送请求后需等待并收到响应之后，才能发送下一个请求。管线化技术出现后，不用等待响应就可直接发送下一个请求。")])])]),t._v(" "),_("p",[_("strong",[t._v("(5）"),_("RouterLink",{attrs:{to:"/网络相关问题.html#常见http状态码"}},[t._v("HTTP结果的状态码")])],1),_("br"),t._v("\nHTTP状态码的职责是当客户端向服务端发送请求时，描述返回的请求结果。通过状态码，用户可以知道服务器是正常的处理了请求，还是出现了错误。"),_("br"),t._v("\n每条HTTP响应报文返回时都会携带一个状态码，状态码是由一个三位数字和原因短语组成，如200 OK。数字的第一位是响应类别(状态码类别)，后两位无分类。")]),t._v(" "),_("h2",{attrs:{id:"常见http状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见http状态码"}},[t._v("#")]),t._v(" 常见http状态码")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[t._v("分类")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("分类描述")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("1**")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("信息，服务器收到请求，需要请求者继续执行操作")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("2**")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("成功，操作被成功接收并处理")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("3**")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("重定向，需要进一步的操作以完成请求")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("4**")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("客户端错误，请求包含语法错误或无法完成请求")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("5**")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("服务器错误，服务器在处理请求的过程中发生了错误")])])])]),t._v(" "),_("details",{staticClass:"custom-block details"},[_("summary",[t._v("点击查看HTTP 状态码")]),t._v(" "),_("ul",[_("li",[t._v("100\tContinue\t继续。客户端应继续其请求")]),t._v(" "),_("li",[t._v("101\tSwitching Protocols\t切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议")]),t._v(" "),_("li",[t._v("200\tOK\t请求成功。一般用于GET与POST请求")]),t._v(" "),_("li",[t._v("201\tCreated\t已创建。成功请求并创建了新的资源")]),t._v(" "),_("li",[t._v("202\tAccepted\t已接受。已经接受请求，但未处理完成")]),t._v(" "),_("li",[t._v("203\tNon-Authoritative Information\t非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本")]),t._v(" "),_("li",[t._v("204\tNo Content\t无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档")]),t._v(" "),_("li",[t._v("205\tReset Content\t重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域")]),t._v(" "),_("li",[t._v("206\tPartial Content\t部分内容。服务器成功处理了部分GET请求")]),t._v(" "),_("li",[t._v("300\tMultiple Choices\t多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择")]),t._v(" "),_("li",[t._v("301\tMoved Permanently\t永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替")]),t._v(" "),_("li",[t._v("302\tFound\t临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI")]),t._v(" "),_("li",[t._v("303\tSee Other\t查看其它地址。与301类似。使用GET和POST请求查看")]),t._v(" "),_("li",[t._v("304\tNot Modified\t未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源")]),t._v(" "),_("li",[t._v("305\tUse Proxy\t使用代理。所请求的资源必须通过代理访问")]),t._v(" "),_("li",[t._v("306\tUnused\t已经被废弃的HTTP状态码")]),t._v(" "),_("li",[t._v("307\tTemporary Redirect\t临时重定向。与302类似。使用GET请求重定向")]),t._v(" "),_("li",[t._v("400\tBad Request\t客户端请求的语法错误，服务器无法理解")]),t._v(" "),_("li",[t._v("401\tUnauthorized\t请求要求用户的身份认证")]),t._v(" "),_("li",[t._v("402\tPayment Required\t保留，将来使用")]),t._v(" "),_("li",[t._v("403\tForbidden\t服务器理解请求客户端的请求，但是拒绝执行此请求")]),t._v(" "),_("li",[t._v('404\tNot Found\t服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面')]),t._v(" "),_("li",[t._v("405\tMethod Not Allowed\t客户端请求中的方法被禁止")]),t._v(" "),_("li",[t._v("406\tNot Acceptable\t服务器无法根据客户端请求的内容特性完成请求")]),t._v(" "),_("li",[t._v("407\tProxy Authentication Required\t请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权")]),t._v(" "),_("li",[t._v("408\tRequest Time-out\t服务器等待客户端发送的请求时间过长，超时")]),t._v(" "),_("li",[t._v("409\tConflict\t服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突")]),t._v(" "),_("li",[t._v("410\tGone\t客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置")]),t._v(" "),_("li",[t._v("411\tLength Required\t服务器无法处理客户端发送的不带Content-Length的请求信息")]),t._v(" "),_("li",[t._v("412\tPrecondition Failed\t客户端请求信息的先决条件错误")]),t._v(" "),_("li",[t._v("413\tRequest Entity Too Large\t由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息")]),t._v(" "),_("li",[t._v("414\tRequest-URI Too Large\t请求的URI过长（URI通常为网址），服务器无法处理")]),t._v(" "),_("li",[t._v("415\tUnsupported Media Type\t服务器无法处理请求附带的媒体格式")]),t._v(" "),_("li",[t._v("416\tRequested range not satisfiable\t客户端请求的范围无效")]),t._v(" "),_("li",[t._v("417\tExpectation Failed\t服务器无法满足Expect的请求头信息")]),t._v(" "),_("li",[t._v("500\tInternal Server Error\t服务器内部错误，无法完成请求")]),t._v(" "),_("li",[t._v("501\tNot Implemented\t服务器不支持请求的功能，无法完成请求")]),t._v(" "),_("li",[t._v("502\tBad Gateway\t作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应")]),t._v(" "),_("li",[t._v("503\tService Unavailable\t由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中")]),t._v(" "),_("li",[t._v("504\tGateway Time-out\t充当网关或代理的服务器，未及时从远端服务器获取请求")]),t._v(" "),_("li",[t._v("505\tHTTP Version not supported\t服务器不支持请求的HTTP协议的版本，无法完成处理")])])]),t._v(" "),_("h2",{attrs:{id:"get请求与post请求的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get请求与post请求的区别"}},[t._v("#")]),t._v(" get请求与post请求的区别")]),t._v(" "),_("p",[t._v("GET和POST是HTTP请求的两种基本方法，最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。"),_("br"),t._v("\nGET和POST的区别使用：\n（1）如果要传递大量数据，比如文件上传，只能用POST请求"),_("br"),t._v("\n（2）GET的安全性比POST要差些，如果包含机密\\敏感信息，建议用POST"),_("br"),t._v("\n（3）如果仅仅是索取数据（数据查询），建议使用GET"),_("br"),t._v("\n（4）如果是增加、修改、删除数据，建议使用POST")]),t._v(" "),_("ul",[_("li",[t._v("GET在浏览器回退时是无害的，而POST会再次提交请求。")]),t._v(" "),_("li",[t._v("GET产生的URL地址可以被Bookmark，而POST不可以。")]),t._v(" "),_("li",[t._v("GET请求会被浏览器主动cache，而POST不会，除非手动设置。")]),t._v(" "),_("li",[t._v("GET请求只能进行url编码，而POST支持多种编码方式。")]),t._v(" "),_("li",[t._v("GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。")]),t._v(" "),_("li",[t._v("GET请求在URL中传送的参数是有长度限制的，而POST么有。")]),t._v(" "),_("li",[t._v("对参数的数据类型，GET只接受ASCII字符，而POST没有限制。")]),t._v(" "),_("li",[t._v("GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。")]),t._v(" "),_("li",[t._v("GET参数通过URL传递，POST放在Request body中。")])]),t._v(" "),_("h2",{attrs:{id:"网络请求几种方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络请求几种方式"}},[t._v("#")]),t._v(" 网络请求几种方式")]),t._v(" "),_("ul",[_("li",[t._v("GET： 请求指定的页面信息，它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，永远不会包含呈现数据。")]),t._v(" "),_("li",[t._v("HEAD： 只请求页面的首部,HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息，用于检查对象是否存在，以及得到对象的元数据。")]),t._v(" "),_("li",[t._v("POST： 向服务器提交数据,请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。")]),t._v(" "),_("li",[t._v("PUT： 从客户端向服务器传送的数据取代指定的文档的内容,PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。")]),t._v(" "),_("li",[t._v("DELETE： 请求服务器删除指定的页面或某一个资源。")]),t._v(" "),_("li",[t._v("OPTIONS： 允许客户端查看服务器的性能。")]),t._v(" "),_("li",[t._v("TRACE： 请求服务器在响应中的实体主体部分返回所得到的内容。")]),t._v(" "),_("li",[t._v("PATCH： 实体中包含一个表，表中说明与该URI所表示的原内容的区别，用于部分文档更改。")]),t._v(" "),_("li",[t._v("MOVE： 请求服务器将指定的页面移至另一个网络地址。")]),t._v(" "),_("li",[t._v("COPY： 请求服务器将指定的页面拷贝至另一个网络地址。")]),t._v(" "),_("li",[t._v("LINK： 请求服务器建立链接关系。")]),t._v(" "),_("li",[t._v("UNLINK： 断开链接关系。")]),t._v(" "),_("li",[t._v("WRAPPED： 允许客户端发送经过封装的请求。")]),t._v(" "),_("li",[t._v("Extension-mothed：在不改动协议的前提下，可增加另外的方法"),_("br"),t._v("\n根据HTTP协议的设计初衷，不同的方法对资源有不同的操作方式\nPUT ：增\nDELETE ：删\nPOST：改\nGET：查\n提示：最常用的是GET和POST（实际上GET和POST都能办到增删改查）")])]),t._v(" "),_("h2",{attrs:{id:"tcp三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[t._v("#")]),t._v(" TCP三次握手")]),t._v(" "),_("p",[t._v("1）主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；"),_("br"),t._v("\n2）主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包 ：“可以，你什么时候发？”，这是第二次对话；"),_("br"),t._v("\n3）主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”， 这是第三次对话。"),_("br"),t._v("\n三次“对话”的目的是使数据包的发送和接收同步， 经过三次“对话”之后，主机A才向主机B正式发送数据。")]),t._v(" "),_("p",[_("strong",[t._v("三次握手过程")]),_("br"),t._v("\n第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。"),_("br"),t._v("\n第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我"),_("br"),t._v('\n第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段："我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。')]),t._v(" "),_("p",[_("strong",[t._v("3次握手的特点")]),_("br"),t._v("\n没有应用层的数据 ,SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0。")]),t._v(" "),_("p",[_("strong",[t._v("断开连接进行4次挥手")]),_("br"),t._v("\n第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；"),_("br"),t._v("\n第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；"),_("br"),t._v("\n第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；"),_("br"),t._v("\n第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。")]),t._v(" "),_("p",[_("strong",[t._v("名词解释")])]),t._v(" "),_("ol",[_("li",[t._v("ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。")]),t._v(" "),_("li",[t._v("SYN 同步序列号，TCP建立连接时将这个位置1。")]),t._v(" "),_("li",[t._v("FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。")])]),t._v(" "),_("p",[t._v("由TCP的三次握手和四次断开可以看出，TCP使用面向连接的通信方式， 大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互， 为数据正式传输打下了可靠的基础。")]),t._v(" "),_("blockquote",[_("p",[_("a",{attrs:{href:"https://blog.csdn.net/ningdaxing1994/article/details/73076795",target:"_blank",rel:"noopener noreferrer"}},[t._v("TCP协议简介"),_("OutboundLink")],1)])]),t._v(" "),_("h2",{attrs:{id:"tcp和udp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp"}},[t._v("#")]),t._v(" TCP和UDP")]),t._v(" "),_("ul",[_("li",[t._v("TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接")]),t._v(" "),_("li",[t._v("TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付")]),t._v(" "),_("li",[t._v("TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的")]),t._v(" "),_("li",[t._v("UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）")]),t._v(" "),_("li",[t._v("每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信")]),t._v(" "),_("li",[t._v("TCP首部开销20字节;UDP的首部开销小，只有8个字节")]),t._v(" "),_("li",[t._v("TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道")]),t._v(" "),_("li",[t._v("TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。")]),t._v(" "),_("li",[t._v("UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDP的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。")]),t._v(" "),_("li",[t._v("TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。")])]),t._v(" "),_("blockquote",[_("p",[_("a",{attrs:{href:"https://www.codecomeon.com/posts/7/",target:"_blank",rel:"noopener noreferrer"}},[t._v("TCP与UDP基本区别"),_("OutboundLink")],1)])]),t._v(" "),_("h2",{attrs:{id:"https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),_("p",[_("strong",[t._v("（1）为什么要使用HTTPS")]),_("br"),t._v("\n上面已经介绍了HTTP协议，虽然HTTP协议用的很普遍，但是它也有些不足。列举如下："),_("br"),t._v("\n通信使用明文(不加密)，内容可能会被窃听。 不验证通信方的身份，因此有可能遭遇伪装。 无法验证报文的完整性，所以有可能已遭篡改。"),_("br"),t._v("\n这些问题不仅在HTTP上出现，其他未加密的协议中也会存在这类问题。"),_("br"),t._v("\n为了统一解决上述这些问题，需要在HTTP上在加入加密处理和认证等机制。我们把添加了加密及认证机制的HTTP称为HTTPS(HTTP Secure)。"),_("br"),t._v("\n简单的说，其实  HTTPS = HTTP  +  加密  +  认证  +  完整性保护。"),_("br"),t._v("\n经常会在Web的登录页面和购物结算界面使用HTTPS通信。使用HTTPS通信时，不再用http://，而是改用https://。当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏会出现一个带锁的标记。")]),t._v(" "),_("p",[_("strong",[t._v("（2）特殊的HTTP")]),_("br"),t._v("\nHTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（Secure Socker Layer）和 TLS（Transport Layer Security）协议代替而已。"),_("br"),t._v("\n通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓HTTPS，其实就是身披 SSL 协议这层外壳的HTTP。"),_("br"),t._v("\nTLS/SSL 是独立于HTTP的协议，是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 协议和 HTTP 协议，所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多的改造。不光是HTTP协议，其他运行在应用层的SMTP 和 Telnet等协议均可配合SSL协议的使用。")]),t._v(" "),_("p",[_("strong",[t._v("（3）为什么不都使用HTTPS")]),_("br"),t._v("\n既然HTTPS那么完全可靠，那为何所有的Web网站不一直使用HTTPS？"),_("br"),t._v("\n主要是因为以下几个原因：")]),t._v(" "),_("ol",[_("li",[t._v("与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能处理的请求数量必定会随之减少。因此，如果是非敏感信息还是用HTTP通信，只有在包含个人敏感数据时，才利用HTTPS加密通信。特别是每当那些访问量较多的Web网站在进行加密处理时，并非对所有内容都进行加密处理，而是仅对那些需要信息隐藏时才会加密，以节约资源。")]),t._v(" "),_("li",[t._v("节约购买证书的开销。要进行HTTPS通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。证书价格根据不同的认证机构略有不同，一年几百到几千的都有，那些购买证书并不合算的服务以及一些个人网站，可能只会选择采用HTTP的通信方式。")]),t._v(" "),_("li",[t._v("HTTPS使用SSL时，它的处理速度会变慢。SSL的慢有两种，一是通信慢，二是大量消耗CPU及内存等资源，导致处理速度变慢。和HTTP相比，网络负载可能会慢2到100倍。除去和TCP连接、发送HTTP请求和响应以外，还必须进行SSL通信，因此整体上处理通行量不可避免会增加。SSL必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此，比起HTTP会更多地消耗服务器和客户端的硬件资源，导致负载增强。当然，可以通过使用SSL加速器这种硬件来改善该问题。")])]),t._v(" "),_("blockquote",[_("p",[_("a",{attrs:{href:"https://www.6miu.com/read-533100.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP 和 HTTPS"),_("OutboundLink")],1)])]),t._v(" "),_("h2",{attrs:{id:"http协议的报文组成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http协议的报文组成"}},[t._v("#")]),t._v(" http协议的报文组成")]),t._v(" "),_("p",[t._v("HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：")]),t._v(" "),_("ul",[_("li",[t._v("起始行（start line）：描述请求或响应的基本信息；")]),t._v(" "),_("li",[t._v("头部字段集合（header）：使用 key-value 形式更详细地说明报文；")]),t._v(" "),_("li",[t._v("空行（CRLF）")]),t._v(" "),_("li",[t._v("消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。")])]),t._v(" "),_("p",[_("strong",[t._v("请求行")]),_("br"),t._v("\n起始行也就是请求行（request line），它简要地描述了客户端想要如何操作服务器端的资源。")]),t._v(" "),_("p",[t._v("请求行由三部分构成：")]),t._v(" "),_("p",[t._v("请求方法：是一个动词，如 GET/POST，表示对资源的操作；")]),t._v(" "),_("p",[t._v("请求目标：通常是一个 URI，标记了请求方法要操作的资源；")]),t._v(" "),_("p",[t._v("版本号：表示报文使用的 HTTP 协议版本。")]),t._v(" "),_("p",[t._v("这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。"),_("br"),t._v(" "),_("code",[t._v("GET / HTTP/1.1")]),t._v(" 在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”")]),t._v(" "),_("p",[_("strong",[t._v("状态行")]),_("br"),t._v("\n看完了请求行，我们再看响应报文里的起始行，在这里它不叫“响应行”，而是叫“状态行”（status line），意思是服务器响应的状态。")]),t._v(" "),_("p",[t._v("比起请求行来说，状态行要简单一些，同样也是由三部分构成：")]),t._v(" "),_("p",[t._v("版本号：表示报文使用的 HTTP 协议版本；")]),t._v(" "),_("p",[t._v("状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；")]),t._v(" "),_("p",[_("code",[t._v("HTTP/1.1 200 OK")]),t._v(" 意思就是：“浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”")]),t._v(" "),_("p",[_("strong",[t._v("头部字段")]),_("br"),t._v("\n请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头"),_("br"),t._v("\n请求头和响应头的结构是基本一样的，唯一的区别是起始行，所以我把请求头和响应头里的字段放在一起介绍。"),_("br"),t._v("\n头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。"),_("br"),t._v("\nHTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。"),_("br"),t._v("\n不过使用头字段需要注意下面几点：")]),t._v(" "),_("ul",[_("li",[t._v("字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；")]),t._v(" "),_("li",[t._v("字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；")]),t._v(" "),_("li",[t._v("字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；")]),t._v(" "),_("li",[t._v("字段的顺序是没有意义的，可以任意排列不影响语义；")]),t._v(" "),_("li",[t._v("字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。")])]),t._v(" "),_("h2",{attrs:{id:"常用头字段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用头字段"}},[t._v("#")]),t._v(" 常用头字段")]),t._v(" "),_("p",[t._v("HTTP首部字段根据实际用途被分为以下4种类型。")]),t._v(" "),_("ul",[_("li",[t._v("通用首部字段（General Header Fields）请求报文和响应报文两方都会使用的首部。")]),t._v(" "),_("li",[t._v("请求首部字段（Request Header Fields）从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。")]),t._v(" "),_("li",[t._v("响应首部字段（ Response Header Fields）从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。")]),t._v(" "),_("li",[t._v("实体首部字段（Entity Header Fields）针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。")])]),t._v(" "),_("p",[_("strong",[t._v("通用首部字段")]),_("br"),t._v("\nCache-Control 控制缓存的行为")]),t._v(" "),_("p",[t._v("Connextion 逐跳首部、连接的管理")]),t._v(" "),_("p",[t._v("Date  创建报文的日期时间")]),t._v(" "),_("p",[t._v("Pragma 报文指令")]),t._v(" "),_("p",[t._v("Transfer-Encoding 指定报文主体的传输编码方式")]),t._v(" "),_("p",[_("strong",[t._v("请求首部字段")]),_("br"),t._v("\nAccept  用户代理可处理的媒体类型")]),t._v(" "),_("p",[t._v("Accept-Charset 优先的字符集")]),t._v(" "),_("p",[t._v("Accept-Encoding  优先的内容编码")]),t._v(" "),_("p",[t._v("Accept-Language  优先的语言")]),t._v(" "),_("p",[t._v("Host  指定资源所在服务器")]),t._v(" "),_("p",[t._v("If-Match  比较实体标记（ETag）")]),t._v(" "),_("p",[t._v("If-Modified-Since 比较资源的更新时间")]),t._v(" "),_("p",[t._v("If-None-Match 比较实体标记（与If-Match相反）  "),_("em",[t._v("合理使用If-None-Match和If-Modified-Since头，可以减少流量带宽。")])]),t._v(" "),_("p",[t._v("Referer 对请求中URI的原始获取方")]),t._v(" "),_("p",[t._v("User-Agent Http客户端程序的信息")]),t._v(" "),_("p",[_("strong",[t._v("响应首部字段")]),_("br"),t._v("\nAccept-Range 是否接受字节范围请求")]),t._v(" "),_("p",[t._v("ETag 资源的匹配信息")]),t._v(" "),_("p",[t._v("Location 另客户端重定向至指定URI")]),t._v(" "),_("p",[t._v("Server Http服务器的安装信息")]),t._v(" "),_("p",[t._v("Vary 代理服务器缓存的管理信息")]),t._v(" "),_("p",[_("strong",[t._v("实体首部字段")]),_("br"),t._v("\nAllow 资源可支持的Http方法")]),t._v(" "),_("p",[t._v("Content-Encoding 实体主体适用的编码方式")]),t._v(" "),_("p",[t._v("Content-Language 实体主体的自然语言")]),t._v(" "),_("p",[t._v("Content-Length 实体主体的大小（字节）")]),t._v(" "),_("p",[t._v("Content-Location 替代对应资源的URI")]),t._v(" "),_("p",[t._v("Content-Type 实体主体的媒体类型")]),t._v(" "),_("p",[t._v("Expires 实体主体过期的日期时间")]),t._v(" "),_("p",[t._v("Last-Modified 资源的最后修改日期时间"),_("br"),t._v(" "),_("strong",[t._v("从以上这些之外，还有比如Cookie、Set-Cookie和Content-Disposition等在其他RFC中定义的首部字段也经常被用到。")])]),t._v(" "),_("h2",{attrs:{id:"强制缓存与协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存与协商缓存"}},[t._v("#")]),t._v(" 强制缓存与协商缓存")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://www.jianshu.com/p/9c95db596df5",target:"_blank",rel:"noopener noreferrer"}},[t._v("彻底弄懂强缓存与协商缓存"),_("OutboundLink")],1),t._v(" "),_("img",{attrs:{src:"/assets/img/http1.png",alt:""}})])])}),[],!1,null,null,null);v.default=T.exports}}]);