(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{618:function(t,s,a){"use strict";a.r(s);var e=a(5),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"父组件可以监听到子组件的生命周期吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父组件可以监听到子组件的生命周期吗"}},[t._v("#")]),t._v(" 父组件可以监听到子组件的生命周期吗？")]),t._v(" "),a("p",[t._v("比如有父组件 "),a("code",[t._v("Parent")]),t._v(" 和子组件 "),a("code",[t._v("Child")]),t._v("，如果父组件监听到子组件挂载"),a("code",[t._v("mounted")]),t._v("就做一些逻辑处理，可以通过以下写法实现：")]),t._v(" "),a("ul",[a("li",[t._v("方法一：使用"),a("code",[t._v("$emit")])])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Parent.vue")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Child @mounted"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"doSomething"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Child.vue")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mounted")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("$emit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"mounted"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("ul",[a("li",[t._v("方法二：使用"),a("code",[t._v("@hook")])])]),t._v(" "),a("p",[t._v("以上需要手动通过"),a("code",[t._v("$emit")]),t._v(" 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过"),a("code",[t._v("@hook")]),t._v("来监听即可，如下所示：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  Parent.vue")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Child @hook"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("mounted"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"doSomething"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Child"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("doSomething")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'父组件监听到 mounted 钩子函数 ...'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  Child.vue")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mounted")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'子组件触发 mounted 钩子函数 ...'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    \n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 以上输出顺序为：")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子组件触发 mounted 钩子函数 ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 父组件监听到 mounted 钩子函数 ...  ")]),t._v("\n")])])]),a("h2",{attrs:{id:"vue-框架怎么实现对象和数组的监听"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-框架怎么实现对象和数组的监听"}},[t._v("#")]),t._v(" Vue 框架怎么实现对象和数组的监听？")]),t._v(" "),a("p",[t._v("如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持。\n同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n   * Observe a list of Array items.\n   */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observeArray")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("items")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Array"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("any"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" l "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" l"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// observe 功能为监测数据的变化")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n   * 对属性进行递归遍历\n   */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" childOb "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("shallow "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("val"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// observe 功能为监测数据的变化")]),t._v("\n")])])]),a("p",[t._v("通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。")]),t._v(" "),a("h2",{attrs:{id:"虚拟dom实现原理及优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom实现原理及优缺点"}},[t._v("#")]),t._v(" 虚拟DOM实现原理及优缺点")]),t._v(" "),a("p",[t._v("虚拟DOM就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。所以，用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制")]),t._v(" "),a("p",[t._v("由于在浏览器中操作DOM是很昂贵的。频繁操作DOM，会产生一定性能问题。这就是虚拟Dom的产生原因。Vue2的Virtual DOM 借鉴了开源库 snabbdom 的实现。Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点，是对真实DOM的一层抽象。"),a("br"),t._v("\n优点："),a("br"),t._v("\n1、保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，他的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多，因此框架的虚拟DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，既保证性能的下限。"),a("br"),t._v("\n2、无需手动操作DOM：我们不需手动去操作DOM，只需要写好 View-Model的 代码逻辑，框架会根据虚拟DOM和数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率。"),a("br"),t._v("\n3、跨平台：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以进行更方便地跨平台操作，例如服务器端渲染、weex开发等等。"),a("br"),t._v("\n缺点："),a("br"),t._v("\n1、无法进行极致优化：虽然虚拟DOM + 合理的优化，足以应对大部分应用的性能需要，但在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化。"),a("br"),t._v("\n2、首次渲染大量DOM时，由于多了一层DOM计算，会比innerHTML插入慢。")]),t._v(" "),a("h2",{attrs:{id:"vue中的key有什么用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue中的key有什么用"}},[t._v("#")]),t._v(" Vue中的key有什么用")]),t._v(" "),a("p",[t._v("key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下："),a("br"),t._v(" "),a("strong",[t._v("对比规则：")]),a("br"),t._v("\n（1）旧虚拟DOM中找到了与新虚拟DOM相同的key："),a("br"),t._v("\n若虚拟DOM中内容没变，直接使用之前的真实DOM！"),a("br"),t._v("\n若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM"),a("br"),t._v("\n（2）旧虚拟DOM中未找到与新虚拟DOM相同的key:"),a("br"),t._v("\n创建新的真实DOM，随后渲染到页面"),a("br"),t._v(" "),a("strong",[t._v("用index作为key可能会引发的问题：")]),a("br"),t._v("\n（1）若对数据进行：逆序添加、逆序删除等破坏顺序操作："),a("br"),t._v("\n会产生没有必要的真实DOM更新==》界面效果没问题，但效率低"),a("br"),t._v("\n（2）如果结构中还包含输入类的DOM  :\n会产生错误DOM更新==》界面有问题"),a("br"),t._v(" "),a("strong",[t._v("开发中如何选择key")]),a("br"),t._v("\n（1）最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值"),a("br"),t._v("\n（2）如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。")]),t._v(" "),a("h2",{attrs:{id:"vue项目优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue项目优化"}},[t._v("#")]),t._v(" vue项目优化")]),t._v(" "),a("p",[t._v("这里只列举针对 Vue 的性能优化，整个项目的性能优化是一个大工程。")]),t._v(" "),a("ul",[a("li",[t._v("对象层级不要过深，否则性能就会差。")]),t._v(" "),a("li",[t._v("不需要响应式的数据不要放在 data 中（可以使用 Object.freeze() 冻结数据）")]),t._v(" "),a("li",[t._v("v-if 和 v-show 区分使用场景")]),t._v(" "),a("li",[t._v("computed 和 watch 区分场景使用")]),t._v(" "),a("li",[t._v("v-for 遍历必须加 key，key最好是id值，且避免同时使用 v-if")]),t._v(" "),a("li",[t._v("大数据列表和表格性能优化 - 虚拟列表 / 虚拟表格")]),t._v(" "),a("li",[t._v("防止内部泄露，组件销毁后把全局变量和时间销毁")]),t._v(" "),a("li",[t._v("图片懒加载")]),t._v(" "),a("li",[t._v("路由懒加载")]),t._v(" "),a("li",[t._v("异步路由")]),t._v(" "),a("li",[t._v("第三方插件的按需加载")]),t._v(" "),a("li",[t._v("适当采用 keep-alive 缓存组件")]),t._v(" "),a("li",[t._v("防抖、节流的运用")]),t._v(" "),a("li",[t._v("服务端渲染 SSR or 预渲染")])]),t._v(" "),a("h2",{attrs:{id:"vue3-0新特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0新特性"}},[t._v("#")]),t._v(" vue3.0新特性")]),t._v(" "),a("ul",[a("li",[t._v("响应式原理的改变 Vue3.x 使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达13种拦截方法。")]),t._v(" "),a("li",[t._v("组件选项声明方式 Vue3.x 使用 Composition API setup是Vue3.x新增的一个选项，他是组件内使用Composition API 的入口。")]),t._v(" "),a("li",[t._v("模板语法变化 slot 具名插槽语法，自定义指令v-model升级。")]),t._v(" "),a("li",[t._v("其他方面的更改 Suspense支持Fragment（多个根节点）和 Protal（在dom其他部分渲染组件内容）组件，针对一些特殊的场景做了处理。基于 treeShaking 优化，提供了更多的内置功能。")])]),t._v(" "),a("h2",{attrs:{id:"一旦进入到页面或者组件-会执行哪些生命周期-顺序。在哪个阶段有-el-哪个阶段有-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一旦进入到页面或者组件-会执行哪些生命周期-顺序。在哪个阶段有-el-哪个阶段有-data"}},[t._v("#")]),t._v(" 一旦进入到页面或者组件，会执行哪些生命周期，顺序。在哪个阶段有$el,哪个阶段有$data")]),t._v(" "),a("ul",[a("li",[t._v("beforeCreate \t\t什么也没有")]),t._v(" "),a("li",[t._v("created \t\t\t有data没有el")]),t._v(" "),a("li",[t._v("beforeMount \t\t有data没有el")]),t._v(" "),a("li",[t._v("mounted \t\t\t都有")])]),t._v(" "),a("h2",{attrs:{id:"props和data优先级谁高"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#props和data优先级谁高"}},[t._v("#")]),t._v(" props和data优先级谁高？")]),t._v(" "),a("p",[t._v("props=> methods => data => computed => watch")]),t._v(" "),a("h2",{attrs:{id:"keep-alive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive"}},[t._v("#")]),t._v(" keep-alive")]),t._v(" "),a("p",[t._v("vue系统自带的一个组件，是用来缓存组件的。提升性能"),a("br"),t._v("\n具体实现比如：首页进入到详情页，当用户在首页每次点击都是相同的，那么详情页就没必要请求多次，直接缓存起来就可以了")]),t._v(" "),a("p",[t._v("如果加入了keep-alive会多两个生命周期"),a("br"),t._v("\nactivated、deactivated"),a("br"),t._v("\n第一次进入组件会执行哪些生命周期？"),a("br"),t._v("\nbeforeCreate、created、beforeMount、mounted、activated"),a("br"),t._v("\n第二次及第N次进入会执行哪些生命周期？"),a("br"),t._v("\n只执行一个生命周期：activated")]),t._v(" "),a("p",[t._v("keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。")]),t._v(" "),a("p",[t._v("常用的两个属性 include/exclude，允许组件有条件的进行缓存。"),a("br"),t._v("\n两个生命周期 activated/deactivated，用来得知当前组件是否处理活跃状态。"),a("br"),t._v("\nkeep-alive 运用了 LRU 算法，选择最近最久未使用的组件予以淘汰。")]),t._v(" "),a("h2",{attrs:{id:"v-if和v-show区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if和v-show区别"}},[t._v("#")]),t._v(" v-if和v-show区别")]),t._v(" "),a("p",[a("strong",[t._v("相同点")]),a("br"),t._v("\nv-if 与 v-show 都可以动态控制 DOM 元素的显示隐藏。"),a("br"),t._v(" "),a("strong",[t._v("不同点")])]),t._v(" "),a("ol",[a("li",[t._v("手段：v-if 是动态的向 DOM 树内添加或者删除 DOM 元素；v-show 是通过设置 DOM 元素的 display 样式属性控制显示隐藏，DOM 元素保留；")]),t._v(" "),a("li",[t._v("编译过程：v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show 只是简单的基于 CSS 切换；")]),t._v(" "),a("li",[t._v("编译条件：v-if 是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载);")]),t._v(" "),a("li",[t._v("v-show 是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且 DOM 元素保留；")]),t._v(" "),a("li",[t._v("性能消耗：v-if 有更高的切换消耗；v-show 有更高的初始渲染消耗；")]),t._v(" "),a("li",[t._v("应用场景：v-if 适合运营条件不大可能改变；v-show 适合频繁切换。")])]),t._v(" "),a("h2",{attrs:{id:"ref是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ref是什么"}},[t._v("#")]),t._v(" ref是什么")]),t._v(" "),a("p",[a("strong",[t._v("ref 有三种用法：")])]),t._v(" "),a("ol",[a("li",[t._v("ref 加在普通的元素上，用this.$refs.（ref值） 获取到的是dom元素")]),t._v(" "),a("li",[t._v("ref 加在子组件上，用this.$refs.（ref值） 获取到的是组件实例，可以使用组件的所有方法。在使用方法的时候直接this.$refs.（ref值）.方法（） 就可以使用了。"),a("br"),t._v(" "),a("strong",[t._v("应注意的坑：")])]),t._v(" "),a("li",[t._v("ref 需要在dom渲染完成后才会有，在使用的时候确保dom已经渲染完成。比如在生命周期 mounted(){} 钩子中调用，或者在 this.$nextTick(()=>{}) 中调用。")]),t._v(" "),a("li",[t._v("如果ref 是循环出来的，有多个重名，那么ref的值会是一个数组 ，此时要拿到单个的ref 只需要循环就可以了。")])]),t._v(" "),a("h2",{attrs:{id:"nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[t._v("#")]),t._v(" nextTick")]),t._v(" "),a("p",[t._v("在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM"),a("br"),t._v(" "),a("strong",[t._v("理解：")]),t._v(" nextTick()，是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数，"),a("br"),t._v(" "),a("strong",[t._v("什么时候需要用的Vue.nextTick()？")])]),t._v(" "),a("ol",[a("li",[t._v("Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。")]),t._v(" "),a("li",[t._v("当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它")]),t._v(" "),a("li",[t._v("在使用某个第三方插件时 ，希望在vue生成的某些dom动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。")])]),t._v(" "),a("p",[t._v("nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法。")]),t._v(" "),a("h2",{attrs:{id:"scoped"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scoped"}},[t._v("#")]),t._v(" scoped")]),t._v(" "),a("p",[a("strong",[t._v("1.作用：")]),a("br"),t._v("\n让样式在本组件中生效，不影响其他组件。")]),t._v(" "),a("p",[a("strong",[t._v("2.原理：")]),a("br"),t._v("\nvue中的scoped 通过在DOM结构以及css样式上加唯一不重复的标记:data-v-hash的方式，以保证唯一（而这个工作是由过PostCSS转译实现的），达到样式私有化模块化的目的。"),a("br"),t._v("\n也就是说既:PostCSS给一个组件中的所有dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。\n"),a("strong",[t._v("3.scoped穿透")]),a("br"),t._v("\nscoped看起来很好用，当时在Vue项目中，当我们引入第三方组件库时(如使用vue-awesome-swiper实现移动端轮播)，需要在局部组件中修改第三方组件库的样式，而又不想去除scoped属性造成组件之间的样式覆盖。我们可以用以下方法")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("在模板中使用两次style标签")]),a("br"),t._v("\n一个vue文件中可以使用多个style标签，在vue组件中不使用scoped属性在vue组件中使用两个style标签，一个加上scoped属性，一个不加scoped属性，把需要覆盖的css样式写在不加scoped属性的style标签里建立一个reset.css(基础全局样式)文件，里面写覆盖的css样式，在入口文件main.js 中引入")]),t._v(" "),a("li",[a("strong",[t._v("穿透scoped")]),a("br"),t._v("\nstyle使用>>>"),a("br"),t._v("\nsass和less的样式穿透 使用    父元素 /deep/ 子元素")])])])}),[],!1,null,null,null);s.default=n.exports}}]);